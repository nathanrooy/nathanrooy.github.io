<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=author content="Nathan Rooy"><meta name=copyright content="Nathan A. Rooy"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=language content="en"><meta http-equiv=content-language content="en-gb"><link rel=icon type=image/png href=/favicon/favicon.png><meta name=google-site-verification content="vQ6uvoBDOPVq7u67m2fO8RWaxcqsoLrLzmR7CzEo-0k"><meta name=msvalidate.01 content="4903EB9C7ABD70347352DCFAEE0751F5"><meta name=yandex-verification content="d0b7b29586e133fc"><script async defer data-domain=nathanrooy.github.io src=https://plausible.io/js/plausible.js></script><title>Word2vec from Scratch with Python and NumPy</title><link rel=canonical href=https://nathanrooy.github.io/posts/2018-03-22/word2vec-from-scratch-with-python-and-numpy/ itemprop=url><base href=https://nathanrooy.github.io/posts/2018-03-22/word2vec-from-scratch-with-python-and-numpy/><meta itemprop=name content="Word2vec from Scratch with Python and NumPy | Nathan Rooy"><meta itemprop=description content="Word2vec from Scratch with Python and NumPy"><meta name=description content="Word2vec from Scratch with Python and NumPy"><meta name=application-name content="Word2vec from Scratch with Python and NumPy | Nathan Rooy"><meta name=twitter:card content="nathanrooy.github.io"><meta name=twitter:url content="https://nathanrooy.github.io/posts/2018-03-22/word2vec-from-scratch-with-python-and-numpy/"><meta name=twitter:title content="Word2vec from Scratch with Python and NumPy | Nathan Rooy"><meta name=twitter:description content="Word2vec from Scratch with Python and NumPy"><meta property="og:title" content="Word2vec from Scratch with Python and NumPy"><meta property="og:description" content="Word2vec from Scratch with Python and NumPy"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://nathanrooy.github.io/posts/2018-03-22/word2vec-from-scratch-with-python-and-numpy/"><meta property="og:site_name" content="nathanrooy.github.io"><meta itemprop=image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta property="og:image" content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image:src content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><link rel=alternate type=application/rss+xml href=https://nathanrooy.github.io/index.xml title="Nathan Rooy"><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><div class="container wrapper post"><div class=header><div style=width:100%;display:inline class=site-title><a style=display:inline href=https://nathanrooy.github.io/>Nathan Rooy</a>
<a style=float:right;padding-left:10px;display:inline target=_blank href=/index.xml title=rss><img style=margin:0;padding-top:.6em src=/icons/rss_feather.svg width=20 height=20></a>
<a style=float:right;padding-left:10px;display:inline target=_blank href=https://github.com/nathanrooy/ title=github><img style=margin:0;padding-top:.6em src=/icons/github_feather.svg width=20 height=20></a></div><hr style=width:100%;display:inline-block><nav class=nav><ul class=flat><li style=text-align:center;vertical-align:top><a href=/><img height=20px style=margin:0;padding:0 src=/icons/home_feather.svg></a></li><li style=text-align:center;vertical-align:top><a href=/about><img height=20px style=margin:0;padding:0 src=/icons/user_feather.svg></a></li><li style=text-align:center;vertical-align:top><a href=/nyc_biking><img height=20px style=margin:0;padding:0 src=/icons/bicycle.svg></a></li><li><a href=/favorites><img height=20px style=margin:0;padding:0 src=/icons/trending-up_feather.svg></a></li></ul></nav></div><div class=post-header><h1 class=title>Word2vec from Scratch with Python and NumPy</h1><div class=meta>Posted: March 22, 2018</div></div><div class=markdown><p class=TLDR><strong>TL;DR</strong> - word2vec is awesome, it's also really simple. Learn how it works, and implement your own version.</p><h3>Introduction</h3><p>Since joining a tech startup back in 2016, my life has revolved around machine learning and natural language processing (NLP). Trying to extract faint signals from terabytes of streaming social media is the name of the game. Because of this, I'm constantly experimenting and implementing different NLP schemes; word2vec being among the simplest and coincidently yielding great predictive value. The underpinnings of word2vec are exceptionally simple and the math is borderline elegant. The whole system is deceptively simple, and provides exceptional results. This tutorial aims to teach the basics of word2vec while building a barebones implementation in <a target=_blank href=https://www.python.org/>Python</a> using <a target=_blank href=http://www.numpy.org/>NumPy</a>. Note that the final Python implementation will not be optimized for speed or memory usage, but instead for easy understanding.</p><p>The goal with word2vec and most NLP embedding schemes is to translate text into vectors so that they can then be processed using operations from linear algebra. Vectorizing text data allows us to then create predictive models that use these vectors as input to then perform something useful. If you understand both forward and back propagation for plain <a target=_blank href=https://en.wikipedia.org/wiki/Multilayer_perceptron>vanella neural networks</a>, you already understand 90% of word2vec.</p><h3>It's Actually Really Simple (I promise!)</h3><p>Word2vec is actually a collection of two different methods: continuous bag-of-words (CBOW) and skip-gram<sup class=footnote-ref id=fnref:fn3><a class=footnote href=#fn:fn3>1</a></sup>. Given a word in a sentence, lets call it w(t) (also called the <i>center word</i> or <i>target word</i>), CBOW uses the <i>context</i> or surrounding words as input. For instance, if the context window <i>C</i> is set to C=5, then the input would be words at positions w(t-2), w(t-1), w(t+1), and w(t+2). Basically the two words before and after the center word w(t). Given this information, CBOW then tries to predict the target word.</p><p><img alt="word2vec network architecture" title="word2vec network architecture" src=word2vec_network_architecture.png>
<center class=figcaption>Figure 1: word2vec CBOW and skip-gram network architectures</center></p><p>The second method, skip-gram is the exact opposite. Instead of inputting the context words and predicting the center word, we feed in the center word and predict the context words. This means that w(t) becomes the input while w(t-2), w(t-1), w(t+1), and w(t+2) are the ideal output. For for this post, we're only going to consider the skip-gram model since it has been shown to produce better word-embeddings than CBOW.</p><p>The concept of a center word surrounded by context words can be likened to a sliding window that travels across the text corpus. As an example, lets encode the following sentence: <i>"the quick brown fox jumps over the lazy dog"</i> using a window size of C=5 (two before, and two after the center word). As the context window slides across the sentence from left to right, it gets populated with the corresponding words. When the context window reaches the edges of the sentences, it simply drops the furthest window positions. Below is what this process looks like. Note that instead of w(t), w(t+1), etc., the center word has become x<sub>k</sub> and the context words have become y<sub>c</sub>.</p><p><img alt="text encoding" title="text encoding" src=text-example.png>
<center class=figcaption>Figure 2: a sliding window example</center></p><p>Because we can't send text data directly through a matrix, we need to employ <a target=blank href=https://en.wikipedia.org/wiki/One-hot>one-hot encoding</a>. This means we have a vector of length <i>v</i> where v is the total number of unique words in the text corpus (or shorter if we want). Each word corresponds to a single position in this vector, so when embedding the word v_n, everywhere in vector v is zero except v_n which becomes a one. Below in Figure 3, a one-hot encoding of examples 1, 5, and 9 from Figure 2 above.</p><p><img alt="one-hot encoding" id=figure-3 title="one-hot encoding" src=training-data.png>
<center class=figcaption>Figure 3: one-hot encoding</center></p><p>→ For future reference, the column vectors <span class=math>\( y_{c=1},...,y_{c=C} \)</span> are referred to as <b><i>panels</i></b>.</p><p>So far, so good right? Now we need to feed this data into the network and train it. Most of the literature describing skip-gram uses the same graphic depicting the final layer of the model somehow having three or more matrices. I found this rather confusing while I was reading the white papers so I ended up digging through the <a target=_blank href=https://github.com/tmikolov/word2vec>original source code</a> to get to the bottom of it. I figure there are other people like me, so I created another version of the architecture that I find a little easier to digest.</p><p><img id=figure-4 alt="skip-gram network architecture" title="skip-gram network architecture" src=skip-gram-architecture.png>
<center class=figcaption>Figure 4: skip-gram network architecture</center></p><h3>Forward Pass</h3><p>Now that the text data has been encoded, lets proceed through a single forward pass of the network. Step one is getting to the hidden layer <i>h</i>.</p><p><span class=math>\[ h = x^T W \]</span></p><p>Since <span class=math>\( x \)</span> is a one-hot encoded vector, <span class=math>\( h \)</span> is simply the <span class=math>\( k^{th} \)</span> row of matrix <span class=math>\( W \)</span>.</p><p><span class=math>\[ h = W_{(k,:)}^T := v_{w_I}^T \]</span></p><p>Preceding forward, we need to calculate the values as they exit the network.</p><p><span class=math>\[ u_c = W^{\prime T} h = W^{\prime T} W^T x \]</span></p><p>Although <span class=math>\( u_c \)</span> gets us through the network, we need to apply a <a target=_blank href=https://en.wikipedia.org/wiki/Softmax_function>softmax</a> function. The softmax will compress each element of <span class=math>\( u_c \)</span> to a range of [0,1] while also forcing the sum of <span class=math>\( u_c \)</span> to equal one. This will help in computing network error and backpropagation later on.</p><p><span class=math>\[
\begin{aligned}
y_c & = Softmax(u) \\[1.5em] 
p \left( w_{c,j} = w_{O,c} | w_I \right) & = y_{c,j} = \frac{exp(u_{c,j})}{\sum_{j^\prime=1}^V exp(u_{j^\prime})}
\end{aligned}
\]</span></p><p>For each one-hot encoded center word <span class=math>\( x \)</span>, matrix <span class=math>\( W^\prime \)</span> will output a certain set of values. This means that all the panels associated with center word <span class=math>\( x \)</span> share the same input values, thus:</p><p><span class=math>\[ u_{c,j} = u_j = {v_{w_j}^{\prime}}^T \cdot h \qquad \text{for} \; c = 1,2,...,C \]</span></p><p>where <span class=math>\( v_{w_j}^{\prime} \)</span> is the output vector of the j-th word in the vocabulary, <span class=math>\( w_j \)</span>. Again because we're dealing with one-hot encodings, this means <span class=math>\( v_{w_j}^{\prime} \)</span> is a column vector taken from the hidden → output matrix <span class=math>\( W^{\prime} \)</span>. Refer to <a href=#figure-4>figure-4</a> for clarity.</p><p>In code, this will take the form of the following:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># FORWARD PASS</span>
<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>forward_pass</span>(self, x):
    h <span style=color:#555>=</span> np<span style=color:#555>.</span>dot(self<span style=color:#555>.</span>w1<span style=color:#555>.</span>T, x)
    u_c <span style=color:#555>=</span> np<span style=color:#555>.</span>dot(self<span style=color:#555>.</span>w2<span style=color:#555>.</span>T, h)
    y_c <span style=color:#555>=</span> self<span style=color:#555>.</span>softmax(u)
    <span style=color:#069;font-weight:700>return</span> y_c, h, u</code></pre></div><p>With the softmax calculation taking the form of:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># SOFTMAX ACTIVATION FUNCTION</span>
<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>softmax</span>(self, x):
    e_x <span style=color:#555>=</span> np<span style=color:#555>.</span>exp(x <span style=color:#555>-</span> np<span style=color:#555>.</span>max(x))
    <span style=color:#069;font-weight:700>return</span> e_x <span style=color:#555>/</span> e_x<span style=color:#555>.</span>sum(axis<span style=color:#555>=</span><span style=color:#f60>0</span>)</code></pre></div><p>The forward pass is fairly simple and differs little from that of a standard, fully connected neural network.</p><h3>Backpropagation & Training</h3><p>Now to improve the weights within <span class=math>\( W \)</span> and <span class=math>\( W^{\prime} \)</span> we're going to use <a target=_blank href=https://en.wikipedia.org/wiki/Stochastic_gradient_descent>stochastic gradient decent</a> (SGD) to <a target=_blank href=https://en.wikipedia.org/wiki/Backpropagation>backpropagate</a> the errors, which means we need to calculate the loss on the output layer.</p><p><span class=math>\[
\begin{aligned}
E & = - \log \mathbb P ( w_{O,1}, w_{O,2},...,w_{O,c} | w_I ) \\[1.5em]
& = -\log \prod_{c=1}^C \frac{ \exp(u_{c,j_c^*})}{\sum_{j^{\prime}=1}^V \exp(u_{j^{\prime}})} \\[1.5em]
& = - \sum_{c=1}^C u_{j_c^*} + C \cdot \log \sum_{j^{\prime}=1}^V \exp(u_{j^{\prime}})
\end{aligned}
\]</span></p><p>where <span class=math>\( j_c^* \)</span> represents the index of the actual c-th output context word in the vocabulary.</p><p>Now that the loss has been calculated, we're going to employ the <a target=_blank href=https://en.wikipedia.org/wiki/Chain_rule>chain rule</a> to distribute the error amongst the weight matrices <span class=math>\( W \)</span> and <span class=math>\( W^{\prime} \)</span>. First step is taking the derivative of <span class=math>\( E \)</span> with respect to every element on every panel of the output layer <span class=math>\( u_{c,j} \)</span>.</p><p><span class=math>\[ \frac{\partial E}{\partial u_{c,j}} = y_{c,j} - t_{c,j} := e_{c,j} \]</span></p><p>Where <span class=math>\( t_{c,j} \)</span> is the ground truth for that particular panel. To simplify the notation going forward, we'll define the following:</p><p><span class=math>\[
EI_j = \sum_{c=1}^C e_{c,j} = \sum_{c=1}^C \left( y_{c,j} - t_{c,j} \right) = \frac{\partial E}{\partial u_j} \tag{2}
\]</span></p><p>The column vector <span class=math>\( EI_j \)</span> represents the row-wise sum of the prediction errors across each context word panel for the current center word. Proceeding backwards, we need to take the derivative of E with respect to <span class=math>\( W^{\prime} \)</span> representing the output → hidden matrix.</p><p><span class=math>\[
\begin{aligned}
\frac{\partial E}{\partial w_{ij}^{\prime}} & = \sum_{c=1}^C \frac{\partial E}{\partial u_{c,j}} \cdot \frac{\partial u_{c,j}}{\partial w_{i,j}^{\prime}} \\[1.5em]
& = \sum_{c=1}^C \left( y_{c,j} - t_{c,j} \right) \\[1.5em]
& = EI_j \cdot h_i
\end{aligned}
\]</span></p><p>Therefore, the gradient decent update equation for <span class=math>\( W^{\prime} \)</span> becomes:</p><p><span class=math>\[ w_{i,j}^{\prime (new)} = w_{i,j}^{\prime (old)} - \eta \cdot EI_j \cdot h_i \]</span></p><p>Note that <span class=math>\( \eta \)</span> is the learning rate. Next, lets formulate the error update equation for the input → hidden layer <span class=math>\( W \)</span> weights by deriving the error with respect to the hidden layer.</p><p><span class=math>\[
\begin{aligned}
\frac{\partial E}{\partial h_{i}} & = \sum_{j=1}^V \frac{\partial E}{\partial u_j} \cdot \frac{\partial u_j}{\partial h_i} \\[1em]
& = \sum_{j=1}^V EI_j \cdot w_{ij}^\prime \\
\end{aligned}
\]</span></p><p>This allows us to then calculate the loss with respect to <span class=math>\( W \)</span>.</p><p><span class=math>\[
\begin{aligned}
\frac{\partial E}{\partial W_{ki}} & = \frac{\partial E}{\partial h_i} \cdot \frac{\partial h_i}{\partial w_{ki}} \\[1em]
& = \sum_{j=1}^V EI_j \cdot w_{ij}^{\prime} \cdot x_k
\end{aligned}
\]</span></p><p>and finally, we can formulate the gradient decent weight update equation for <span class=math>\( W \)</span>.</p><p><span class=math>\[ w_{ij}^{(new)} = w_{ij}^{(old)} - \eta \cdot \sum_{j=1}^V EI_j \cdot w_{ij}^{\prime} \cdot x_j \]</span></p><p>At this point, everything needed to train the network has been established and we just need to code it.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># TRAIN W2V model</span>
<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>train</span>(self, training_data):
    <span style=color:#09f;font-style:italic># INITIALIZE WEIGHT MATRICES</span>
    self<span style=color:#555>.</span>w1 <span style=color:#555>=</span> np<span style=color:#555>.</span>random<span style=color:#555>.</span>uniform(<span style=color:#555>-</span><span style=color:#f60>0.8</span>, <span style=color:#f60>0.8</span>, (self<span style=color:#555>.</span>v_count, self<span style=color:#555>.</span>n))     <span style=color:#09f;font-style:italic># context matrix</span>
    self<span style=color:#555>.</span>w2 <span style=color:#555>=</span> np<span style=color:#555>.</span>random<span style=color:#555>.</span>uniform(<span style=color:#555>-</span><span style=color:#f60>0.8</span>, <span style=color:#f60>0.8</span>, (self<span style=color:#555>.</span>n, self<span style=color:#555>.</span>v_count))     <span style=color:#09f;font-style:italic># embedding matrix</span>

    <span style=color:#09f;font-style:italic># CYCLE THROUGH EACH EPOCH</span>
    <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>, self<span style=color:#555>.</span>epochs):

        self<span style=color:#555>.</span>loss <span style=color:#555>=</span> <span style=color:#f60>0</span>

        <span style=color:#09f;font-style:italic># CYCLE THROUGH EACH TRAINING SAMPLE</span>
        <span style=color:#069;font-weight:700>for</span> w_t, w_c <span style=color:#000;font-weight:700>in</span> training_data:

            <span style=color:#09f;font-style:italic># FORWARD PASS</span>
            y_pred, h, u <span style=color:#555>=</span> self<span style=color:#555>.</span>forward_pass(w_t)

            <span style=color:#09f;font-style:italic># CALCULATE ERROR</span>
            EI <span style=color:#555>=</span> np<span style=color:#555>.</span>sum([np<span style=color:#555>.</span>subtract(y_pred, word) <span style=color:#069;font-weight:700>for</span> word <span style=color:#000;font-weight:700>in</span> w_c], axis<span style=color:#555>=</span><span style=color:#f60>0</span>)

            <span style=color:#09f;font-style:italic># BACKPROPAGATION</span>
            self<span style=color:#555>.</span>backprop(EI, h, w_t)

            <span style=color:#09f;font-style:italic># CALCULATE LOSS</span>
            self<span style=color:#555>.</span>loss <span style=color:#555>+=</span> <span style=color:#555>-</span>np<span style=color:#555>.</span>sum([u[word<span style=color:#555>.</span>index(<span style=color:#f60>1</span>)] <span style=color:#069;font-weight:700>for</span> word <span style=color:#000;font-weight:700>in</span> w_c]) <span style=color:#555>+</span> <span style=color:#366>len</span>(w_c) <span style=color:#555>*</span> np<span style=color:#555>.</span>log(np<span style=color:#555>.</span>sum(np<span style=color:#555>.</span>exp(u)))

        <span style=color:#069;font-weight:700>print</span> <span style=color:#c30>&#39;EPOCH:&#39;</span>,i, <span style=color:#c30>&#39;LOSS:&#39;</span>, self<span style=color:#555>.</span>loss
    <span style=color:#069;font-weight:700>pass</span></code></pre></div><p>Where the backpropagation function is defined as:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># BACKPROPAGATION</span>
<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>backprop</span>(self, e, h, x):
    dl_dw2 <span style=color:#555>=</span> np<span style=color:#555>.</span>outer(h, e)  
    dl_dw1 <span style=color:#555>=</span> np<span style=color:#555>.</span>outer(x, np<span style=color:#555>.</span>dot(self<span style=color:#555>.</span>w2, e<span style=color:#555>.</span>T))

    <span style=color:#09f;font-style:italic># UPDATE WEIGHTS</span>
    self<span style=color:#555>.</span>w1 <span style=color:#555>=</span> self<span style=color:#555>.</span>w1 <span style=color:#555>-</span> (self<span style=color:#555>.</span>eta <span style=color:#555>*</span> dl_dw1)
    self<span style=color:#555>.</span>w2 <span style=color:#555>=</span> self<span style=color:#555>.</span>w2 <span style=color:#555>-</span> (self<span style=color:#555>.</span>eta <span style=color:#555>*</span> dl_dw2)
    <span style=color:#069;font-weight:700>pass</span></code></pre></div><p>That's it! Only slightly more complicated than a simple neural network. To avoid posting redundant sections of code, you can find the completed word2vec model along with some additional features at this GitHub repo (<a target=_blank href=https://github.com/nathanrooy/word2vec-from-scratch-with-python/blob/master/word2vec.py>here</a>).</p><h3>Results</h3><p>As a simple sanity check, lets look at the network output given a few input words. This is the output after 5000 iterations.</p><table class=results-table style="width:100%;border-spacing:20px 0;text-align:center"><thead><tr><th style="text-align:center;border-right:1px solid #000"><strong>Input word</strong></th><th style=text-align:center><strong>brown</strong></th><th style=text-align:center><strong>dog</strong></th><th style=text-align:center><strong>fox</strong></th><th style=text-align:center><strong>jumps</strong></th><th style=text-align:center><strong>lazy</strong></th><th style=text-align:center><strong>over</strong></th><th style=text-align:center><strong>quick</strong></th><th style=text-align:center><strong>the</strong></th></tr></thead><tbody style=font-size:11px;text-align:center><tr><td style="color:#9f1f63;font-size:14px;border-right:1px solid #000">fox</td><td style=background-color:#13a89e;color:#fff>2.45e-01</td><td>4.34e-04</td><td>4.45e-04</td><td style=background-color:#13a89e;color:#fff;margin-right:5px>2.53e-01</td><td>2.34e-05</td><td style=background-color:#13a89e;color:#fff>2.53e-01</td><td style=background-color:#13a89e;color:#fff>2.45e-01</td><td>7.62e-07</td></tr><tr><td style="color:#9f1f63;font-size:14px;border-right:1px solid #000">lazy</td><td>5.81e-05</td><td style=background-color:#13a89e;color:#fff>3.32e-01</td><td>2.42e-04</td><td>1.11e-05</td><td>1.91e-04</td><td style=background-color:#13a89e;color:#fff>3.33e-01</td><td>4.51e-04</td><td style=background-color:#13a89e;color:#fff>3.33e-01</td></tr><tr><td style="color:#9f1f63;font-size:14px;border-right:1px solid #000">dog</td><td>1.85e-07</td><td>3.17e-04</td><td>1.31e-03</td><td>1.29e-04</td><td style=background-color:#13a89e;color:#fff>4.98e-01</td><td>1.42e-05</td><td>4.86e-06</td><td style=background-color:#13a89e;color:#fff>4.99e-01</td></tr></tbody></table><p>These sample results show that the output probabilities for each center word are split fairly evenly between the correct context word. If we narrow in on the word <strong><i>lazy</i></strong>, we can see that the probabilities for the words <strong><i>dog</i></strong>, <strong><i>over</i></strong>, and <strong><i>the</i></strong> are split fairly evenly at roughly 33.33% each. This is exactly what we want.</p><h3>Improvements</h3><p>Shortly after the initial release of word2vec, a second paper detailing several improvements was published.<sup class=footnote-ref id=fnref:fn2><a class=footnote href=#fn:fn2>2</a></sup> Amongst these proposed improvements are:</p><p><strong>Phrase Generation</strong> — This is the process in which commonly co-occuring words such as "san" and "francisco" become "san_francisco". The result of phrase generation is a cleaner, more useful, and user-friendly vocabulary list. Phrase generation is based on the following equation which utilizes the unigram and bigram vocabulary counts for the given corpus.</p><p><span class=math>\[ score(w_a, w_b) = \frac{count(w_aw_b) - \delta}{count(w_a) \times count(w_b)} \]</span></p><p>The numerator consists of the total number of times the bigram formed with words <span class=math>\( w_a \)</span> and <span class=math>\( w_b \)</span> appears in the corpus. This is then divided by the counts of <span class=math>\( w_a \)</span> multiplied by <span class=math>\( w_b \)</span>. The variable <span class=math>\( \delta \)</span> is referred to as the <i>discounting coefficient</i> and prevents the formation of word phrases consisting of very infrequent words.<sup class=footnote-ref id=fnref:fn2><a class=footnote href=#fn:fn2>3</a></sup></p><p>For longer word combinations such as "new york city", an iterative phrase generation approach can be used. As an example, on the initial pass "new" and "york" could be combined into "new_york", with a second pass combining "new_york" with "city" yielding the desired phrase "new_york_city". According to Mikolov et al. (<a href=#fn:fn2>2013</a>), typically 2-4 passes with decreasing threshold values yielded the best results.</p><p><strong>Subsampling</strong> — The purpose of subsampling is to counter the balance between frequent and rare words. No single word should represent a sizable portion of the corpus. To correct for this all words are discarded based on the following probability:</p><p><span class=math>\[ P \left( w_i \right) = 1 - \sqrt{\frac{t}{f \left( w_i \right)}} \]</span></p><p>Where <span class=math>\( f(w_i) \)</span> is the frequency of word <span class=math>\( w_i \)</span> and <span class=math>\( t \)</span> is a user specified threshold. In Mikolov et al. (<a href=#fn:fn2>2013</a>), values for <span class=math>\( t \)</span> were typically around 10<sup>-5</sup>. As pointed out <a target=_blank href=http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/>here</a>, this probability calculation differs from the <a target=_blank href=https://github.com/tmikolov/word2vec>official word2vec C implementation</a>. Below is the modified equation found in the C implementation:</p><p><span class=math>\[ P(w_i) = \left( \sqrt{\frac{z(w_i)}{0.001}} + 1 \right) \times \frac{0.001}{z(w_i)} \]</span></p><p>Where <span class=math>\( z(w_i) \)</span> is the fraction of the corpus represented by the word <span class=math>\( w_i \)</span>. The higher <span class=math>\( P(w_i) \)</span> is, the greather the chances are of keeping <span class=math>\( w_i \)</span>.</p><p><strong>Negative Sampling</strong> — Often referred to as just NEG, this is a modification to the backpropagation procedure in which only a small percentage of the errors are actually considered. For instance, using example #9 from <a href=#figure-3>figure 3</a> above, <strong><i>dog</i></strong> is the target word, while <strong><i>the</i></strong> and <strong><i>lazy</i></strong> are the context words. This means that in an ideal situation, the network will return a "0" for everything except for <strong><i>the</i></strong> and <strong><i>lazy</i></strong> which will be "1". In short, context words become "positive" while everything else becomes "negative". With negative sampling, we only concern ourselves with the positive words and only a small percentage of the negative words. This means that instead of backpropagating the errors from all 8 words in the vocabulary, we backpropagate the errors from the positive words <strong><i>the</i></strong> and <strong><i>lazy</i></strong> plus <span class=math>\( k \)</span> negative words. Because the vocabulary size in this example is only 8, the advantage of negative sampling may not be immediately apparent. Now, imagine for a moment that you have a corpus that yielded billions of training samples, you've had to clip your vocabulary to 10,000 words and your embedding vector length is 300. With negative sampling we're updating a few positive words, and a few negative words (lets say <span class=math>\( k = 10\)</span>) which translates to only 3,000 individual weights in W<sup>'</sup>. This represents 0.1% of the 3 million weight values we would otherwise be updating without negative sampling!</p><p>The probability that a negative word is chosen is determined using the following equation:</p><p><span class=math>\[ \log p(w|w_I) = \log \sigma (v_w^{\prime T} v_{w_I}) + \sum_{i=k}^K E_{w_i ~ P_n(w)} [\log \sigma(-v_w^{\prime T} v_{w_I})]\]</span></p><p>As we can see, the primary difference between this and the standard stochastic gradient decent version is that now we include K observations. As for how large k should be, Mikolov et al. had this to say:</p><blockquote>Our experiments indicate that values of <i>k</i> in the range 5–20 are useful for small training datasets, while for large datasets the <i>k</i> can be as small as 2–5.<p style=text-align:right;padding-bottom:0;padding-top:1rem>- Mikolov et al. (<a href=#fn:fn2>2013</a>)</p></blockquote><p>Something to keep in mind however is that the official C implementation uses a slightly different formulation as seen below<sup class=footnote-ref id=fnref:fn5><a class=footnote href=#fn:fn5>4</a></sup>:</p><p><span class=math>\[ P(w_i) = \frac{f(w_i)^{3/4}}{\sum_{j=0}^n \left( f(w_j)^{3/4} \right)} \]</span></p><p>Note that even without negative sampling, only the weights for the target word in matrix W are updated.</p><h3>Conclusion</h3>Thanks for reading, I hope you found this useful! If anything still seems unclear, please let me know so I can improve this tutorial. For further reading, I highly suggest working through each of the references below.<h3>References</h3><div class=footnotes><hr><ol><li id=fn:fn3>Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean. <a class=inline_link target=_blank href=https://arxiv.org/abs/1301.3781>Efficient Estimation of Word Representations in Vector Space</a> (Submitted on 16 Jan 2013)
<a class=footnote-return href=#fnref:fn3><sup>[return]</sup></a></li><li id=fn:fn2>Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, Jeffrey Dean. <a class=inline_link target=_blank href=https://arxiv.org/abs/1310.4546>Distributed Representations of Words and Phrases and their Compositionality</a> (Submitted on 16 Oct 2013)
<a class=footnote-return href=#fnref:fn2><sup>[return]</sup></a></li><li id=fn:fn2>Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, Jeffrey Dean. <a class=inline_link target=_blank href=https://arxiv.org/abs/1310.4546>Distributed Representations of Words and Phrases and their Compositionality</a> (Submitted on 16 Oct 2013)
<a class=footnote-return href=#fnref:fn2><sup>[return]</sup></a></li><li id=fn:fn5>Chris McCormick. <a target=_blank href=http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/>Word2Vec Tutorial Part 2 - Negative Sampling</a> (January 11, 2017)
<a class=footnote-return href=#fnref:fn5><sup>[return]</sup></a></li></ol></div></div><hr></div><div class=footer><center>&copy; <a href=/about>Nathan A. Rooy</a>.<br>Built with <a target=_blank href=https://gohugo.io/ rel=nofollow>Hugo</a>.
Powered by <a target=_blank href=http://www.github.com>GitHub</a></center></div></body></html>