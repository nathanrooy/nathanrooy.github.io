<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=author content="Nathan Rooy"><meta name=copyright content="Nathan A. Rooy"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=language content="en"><meta http-equiv=content-language content="en-gb"><link rel=icon type=image/png href=/favicon/favicon.png><meta name=google-site-verification content="vQ6uvoBDOPVq7u67m2fO8RWaxcqsoLrLzmR7CzEo-0k"><meta name=msvalidate.01 content="4903EB9C7ABD70347352DCFAEE0751F5"><meta name=yandex-verification content="d0b7b29586e133fc"><script async defer data-domain=nathanrooy.github.io src=https://plausible.io/js/plausible.js></script><title>BlenderFOAM: Open-source Fluid Based Shape Optimization</title><link rel=canonical href=https://nathanrooy.github.io/posts/2019-03-05/blenderfoam-aerodynamic-shape-optimization/ itemprop=url><base href=https://nathanrooy.github.io/posts/2019-03-05/blenderfoam-aerodynamic-shape-optimization/><meta itemprop=name content="BlenderFOAM: Open-source Fluid Based Shape Optimization | Nathan Rooy"><meta itemprop=description content="BlenderFOAM: Open-source Fluid Based Shape Optimization"><meta name=description content="BlenderFOAM: Open-source Fluid Based Shape Optimization"><meta name=application-name content="BlenderFOAM: Open-source Fluid Based Shape Optimization | Nathan Rooy"><meta name=twitter:card content="nathanrooy.github.io"><meta name=twitter:url content="https://nathanrooy.github.io/posts/2019-03-05/blenderfoam-aerodynamic-shape-optimization/"><meta name=twitter:title content="BlenderFOAM: Open-source Fluid Based Shape Optimization | Nathan Rooy"><meta name=twitter:description content="BlenderFOAM: Open-source Fluid Based Shape Optimization"><meta property="og:title" content="BlenderFOAM: Open-source Fluid Based Shape Optimization"><meta property="og:description" content="BlenderFOAM: Open-source Fluid Based Shape Optimization"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://nathanrooy.github.io/posts/2019-03-05/blenderfoam-aerodynamic-shape-optimization/"><meta property="og:site_name" content="nathanrooy.github.io"><meta itemprop=image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta property="og:image" content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image:src content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><link rel=alternate type=application/rss+xml href=https://nathanrooy.github.io/index.xml title="Nathan Rooy"><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/normalize.min.02d927c3d7aee93f4557abffff0169f2c90a749e49700a80350d5b3f2911e20a.css><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/main.min.a9cb0519e65e1b0a59464d400acd5556dea276d442d87b69a4465fa195513ae7.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><div class="container wrapper post"><div class=header><div style=width:100%;display:inline class=site-title><a style=display:inline href=https://nathanrooy.github.io/>Nathan Rooy</a>
<a style=float:right;padding-left:10px;display:inline target=_blank href=/index.xml title=rss><img style=display:inline;margin:0;vertical-align:bottom src=/icons/rss_feather.svg width=20 height=20 alt="rss icon"></a>
<a style=float:right;padding-left:10px;display:inline target=_blank rel="noopener noreferrer" href=https://github.com/nathanrooy/ title=github><img style=display:inline;margin:0;vertical-align:bottom src=/icons/github_feather.svg width=20 height=20 alt="github page icon"></a></div><hr style=width:100%;display:inline-block><nav class=nav><ul class=flat><li style=text-align:center;vertical-align:top><a href=/><img style=margin:0;padding:0;width:20px;height:20px src=/icons/home_feather.svg alt="home page icon"></a></li><li style=text-align:center;vertical-align:top><a href=/about><img style=margin:0;padding:0;width:20px;height:20px src=/icons/user_feather.svg alt="about page icon"></a></li><li style=text-align:center;vertical-align:top><a href=/nyc_biking><img style=margin:0;padding:0;width:35px;height:20px src=/icons/bicycle.svg alt="biking page icon"></a></li><li><a href=/favorites><img style=margin:0;padding:0;width:20px;height:20px src=/icons/trending-up_feather.svg alt="personal favorites icon"></a></li></ul></nav></div><div class=post-header><h1 class=title>BlenderFOAM: Open-source Fluid Based Shape Optimization</h1><div class=meta>Posted: March 5, 2019</div></div><div class=markdown><p class=TLDR><strong>TL;DR</strong> - Aerodynamic shape optimization for the masses.</p><h2>Introduction</h2><p>I was recently cleaning out my closet and came across an old hard drive labeled "grad school". After plugging it in and exploring it for a few minutes, I came across all my old thesis stuff. Seeing how this was before I started using GitHub, I figured I would post it in hopes that someone else could get some use from it. Even though it uses older versions of both Blender and OpenFOAM, the results should still be perfectly acceptable given that the equations of fluid dynamics haven't changed much in the last hundred years.</p><h2>Background</h2><p>Given the ubiquity of cheap computing power both locally and in the cloud, the number of industries that deal with <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Computational_fluid_dynamics>computational fluid dynamics</a> (CFD) based <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Shape_optimization>shape optimization</a> continues to grow. What started out as a niche skill set for aerospace applications expanded out into high high-end motorsport and naval applications. Now, CFD based aerodynamic shape optimization is a key step in the design process for every major automotive company. And if the adoption of electric vehicles continues, aerodynamic shape optimization will only become more important. The simplest, cheapest way to increase electic vehicle range is through aerodynamic drag reduction. Same thing applies to ground based shipping. A small reduction in drag across an entire fleet of trucks means massive savings overall. BlenderFOAM was my thesis project and solution to this problem. It's based entirely on open-source software, more specifically: <a target=_blank rel="noopener noreferrer" href=https://www.blender.org/>Blender</a>, <a target=_blank rel="noopener noreferrer" href=https://openfoam.org/>OpenFOAM</a>, and <a target=_blank rel="noopener noreferrer" href=https://www.python.org/>Python</a>.</p><p>OpenFOAM or Open Field Operation and Manipulation is an open-source toolbox that facilitates numerical solving and pre-/post-processing of <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Continuum_mechanics>continuum mechanics</a> problems. Written in C++, OpenFOAM specializes in solving CFD simulations in massively parallel environments. Development of the original OpenFOAM started in the late 1980's at Imperial College, London. Its development was initiated because of a need for more a powerful and flexible simulation platform. At the time, Fortran was the defacto standard for writing simulation code, however C++ was chosen as the programming language due to its higher modularity and object-oriented features. A distinct advantage of OpenFOAM over other black box commercial CFD codes is its complete transparency which makes it easy to modify or integrate custom written modules such as experimental turbulence models. This ease of custom development stems from OpenFOAM's syntax which closely resembles the tensor operations and partial differential equations being solved. If anyone tells you they're a CFD expert and doesn't use OpenFOAM, turn around and walk away. Every solver that isn't OpenFOAM (Ansys, STAR-CCM+, Exa, etc...) are for children.</p><p>Blender on the other hand is an open source design tool produced by the Blender Foundation and used primarily for graphics and animation. Its origin can be traced back to an in-house design tool used by the Dutch commercial animation company NeoGeo and Not a Number (NaN). When NaN went bankrupt in 2002, Blender source code was released and the Blender Foundation was formed to continue software development. Blender is primarily used for animated films and highly detailed static renderings. In addition, Blender is capable of producing interactive 3D applications and video games. Within Blender, a rich diversity of mesh creation and deformation tools are available and all accessible from the built-in python API. This enables complete automation via the terminal using batch scripts or Python. Users can also use Python to develop custom tools that can be easily implemented into the GUI. A distinct advantage of Blender is its very low hardware requirements which allows for rapid mesh deformation of high-resolution models to occur very quickly on a standard desktop computer. This lends itself very well to the task of aerodynamic shape optimization.</p><h2>Geometry Parameterization</h2><p>Before any shape optimization can take place, the geometry must be <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Parametrization_(geometry)>parameterized</a>. Since Blender lacks support for parametric geometry, CAD files must be converted into a triangulated surface mesh and imported as an <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/STL_(file_format)>stl</a>. Once the geometry is in Blender though, it can be parameterized using one or several different methods.</p><p>The most common mesh deformation method I find myself using is the <a target=_blank rel="noopener noreferrer" href=https://docs.blender.org/manual/en/latest/rigging/lattice.html>lattice</a>. It's simple, easy to use, and gets the job done. The lattice mesh deformation tool (figure [1]) is Blenders implementation of a free-form deformation method. It is initiated by the creation of a 3D bounding box which is then filled with a user specified number of evenly spaced control points along each principal axis. These control points can then be maneuvered, manipulating the geometry accordingly using a <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/B-spline>volumetric B-spline</a> function. This B-spline approach allows the lattice to have a localized impact on the geometry which spans no more than two control points in distance.</p><p><img title="blender lattice mesh deformation" alt="blender lattice mesh deformation" width=400 src=Mesh_Deformation_LATTICE.png>
<center class=figcaption>Figure 1: Lattice</center></p><p>Sometimes, one lattice just doesn't deliver enough deformation fidelity and you need to use several. No Problem! Blender is a beast, and will gladly support any number of additional lattices. This enables users to create a finely tuned parametric mesh, ready for optimization. This permits optimization on different length scales which for most real world applications is a must. Seen below in figure [2], additional lattices have been implemented to increase shape control.</p><p><img title="blender lattice mesh deformation" alt="blender lattice mesh deformation" width=400 src=Mesh_Deformation_LATTICE_3.png>
<center class=figcaption>Figure 2: Multiple lattices</center></p><p>If one or more lattices fail to deliver, the next option is a cage. From the users perspective, the cage deformation tool (figure [3]) is very similar to the lattice tool. Control points are manually created and formed into a cage encompassing the geometry. This cage is free to take any shape the designer requires so long as it forms a closed surface. The control points forming this cage can then be adjusted, manipulating the geometry within. This enables a potentially large reduction in the number of control points, thus reducing the design space through intuitive placement of control points. The Blender cage system is based on work done at Pixar.<sup class=footnote-ref id=fnref:fn1><a class=footnote href=#fn:fn1>1</a></sup> The cage method operates by first embedding itself to the geometry volume by solving Laplace's equation. From this solution, the influence of each control point on the geometry is now known. Because of the global nature of elliptic PDEs, each control point has a theoretical influence on all parts of the geometry. In practice however, the influence of a control point on the geometry surface decays rapidly. An advantage of the cage method is that once it has been embedded to the geometry surface, deformations are extremely rapid, requiring only matrix-vector products.</p><p><img title="blender cage deformation" alt="blender cage deformation" width=400 src=Mesh_Deformation_CAGE.png>
<center class=figcaption>Figure 3: Cage</center></p><p>The last form of geometry manipulation comes from actual point manipulation of the geometry (figure [4]). This method is basic and primitive, however in some circumstances it may prove to be the most useful.</p><p><img title="blender direct deformation" alt="blender direct deformation" width=400 src=Mesh_Deformation_DIRECT.png>
<center class=figcaption>Figure 4: Direct</center></p><p>Overall, Blender supports a rich environment for mesh deformation. The covered techniques can not only run in series together on a single feature, they are only a small sample of whats available to designers. And thanks to Blender's built-in Python API, custom techniques are a simple addition.</p><h2>Optimizer Performance</h2><p>A simple way to measure both optimizer performance and geometry parameterization is through an inverse design challenge. Starting off with the Tyrrell 26 airfoil which used on the front wing of the 1998 Tyrrell Formula 1 car seen below in figure [5], the geometry will be subjected to a random perturbation using a lattice resulting in a completely new airfoil shape.</p><p><img title="blender direct deformation" alt="blender direct deformation" src=tyrrell1998.jpg>
<center class=figcaption>Figure 5: Tyrrell from 1998</center></p><p>The goal of this exercise will then be to recover the deformed shape back to the original airfoil in as few iterations as possible. To get a better understanding of performance, two tests will be carried using lattices of different resolutions.</p><p><img style=display:inline-block width=49% title="inverse design results (4)" alt="inverse design results (4 control points)" src=Benchmark_0_Lattice4_initial.png>
<img style=display:inline-block width=49% title="inverse design results (4)" alt="inverse design results (4 control points)" src=Benchmark_0_lattice4_deformed.png>
<center class=figcaption>Figure 6: Target (left) and deformed (right) - 4 control points</center></p><p><img style=display:inline-block width=49% title="inverse design results (10)" alt="inverse design results (10 control points)" src=Benchmark_0_lattice10_initial.png>
<img style=display:inline-block width=49% title="inverse design results (10)" alt="inverse design results (10 control points)" src=Benchmark_0_lattice10_deformed.png>
<center class=figcaption>Figure 7: Target (left) and deformed (right) - 10 control points</center></p><p>To quantify the difference between the initially perturbed airfoil and the target airfoil, a purely geometric cost function has been created. It can be seen from equation [1] below that it's simply the squared sum of the distance between the actual and target vertices.</p><p><span class=math>\[ \delta = \sum_{i=1}^{n verts} \left(v_i - v_i^*\right)^2 \tag{1} \]</span></p><p>From equation [1], <span class=math>\( v_i \)</span> are the current airfoil vertex coordinates and <span class=math>\( v_i^* \)</span>, are the corresponding target vertex coordinates. The optimizers for this exercise have been assigned a maximum function evaluation limit of 1500 and a convergence tolerance criteria of 1e-03.</p><p><img title="inverse design results (4 control points)" alt="inverse design results (4 control points)" width=500 src=BENCHMARK_0_lattice_04.png>
<img title="inverse design results (10 control points)" alt="inverse design results (10 control points)" width=500 src=BENCHMARK_0_lattice_10.png>
<center class=figcaption>Figure 8: Shape matching results, 4 control points (top), 10 control points (bottom)</center></p><p>From figure 8 above, it can be seen that Blender and the associated optimizers are able to fully recover the airfoil geometry within a respectable number of iterations. Of note is the relative ease in which <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/BOBYQA>BOBYQA</a> and <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/NEWUOA>NEWUOA</a> were able to converge quickest in both a 4 and 10 dimensional space. This hints at the fact that this scenario is likely a fairly smooth, unimodal problem.</p><h2>Multi-objective Airbox Design</h2><p>For this test, BlenderFOAM will be challenged to optimize the performance of a <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Formula_Ford>Formula Ford</a> airbox as seen below in figure [9]. This geometry was chosen because it represents one of the most common parts in the world of motorsport. Almost every vehicle features an airbox of some sort, making it a highly engineered component.</p><p><img src=Airbox3View.jpg alt="formula ford airbox">
<center class=figcaption>Figure 9: Formula Ford airbox</center></p><p>The purpose of an <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Airbox>airbox</a> is to deliver large amounts of air to the engine as painlessly as possible. Therefore the objective is to make the airbox as efficient as possible by minimizing the pressure loss between the inlet and outlet. The more efficient an airbox is, the easier the engine can breathe resulting in better performance.</p><p>A multi-objective approach has been used here because when optimized for purely a pressure loss improvement, the pressure distribution at the outlet can become highly uneven with a large amount of high pressure developing along the edges. For this reason, the pressure loss will be minimized while also minimizing the standard deviation of the velocity magnitude at the outlet.</p><p><img style=display:inline-block width=49% src=Benchmark_4_lattice2.jpg alt="formula ford airbox parameterization">
<img style=display:inline-block width=49% src=Benchmark_4_latticeClose.jpg alt="formula ford airbox parameterization">
<center class=figcaption>Figure 10: Airbox parameterization</center></p><p>The airbox geometry was parameterized using two lattices, one for macro scale structural deformations and a smaller one was located near the neck to reduce the chances of initial flow separation. Using the simpleFOAM solver along with the <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/SST_(Menter%E2%80%99s_Shear_Stress_Transport)>SST K-ω turbulence model</a>, the inlet has been assigned a velocity of 30 m/s (67.1081 mph) normal to the inlet plain with an outlet pressure of 0.0 Pa. Note that this setup has been heavily simplified relative to what is normally considered ideal. A setup more aligned with motorsport best practices would include optimizing across a range of inlet velocities (Reynolds sweep), inlet velocity directions, initial turbulence levels, and varying outlet pressure levels as well as external geometric constraints. In addition, simpleFOAM which is a <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Reynolds-averaged_Navier%E2%80%93Stokes_equations>RANS</a> based solver should be swapped for a <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Detached_eddy_simulation>DES</a> or <a target=_blank rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Large_eddy_simulation>LES</a> based approach to better resolve small-scale, time-dependent turbulence structures. Lastly, because this was ran on my laptop and thus computationally limited, cell count was kept low at 323,480.</p><p><img style=display:inline-block width=49% src=Benchmark_4_P_INITIAL.jpg alt="initial velocity magnitude">
<img style=display:inline-block width=49% src=Benchmark_4_P_NEWUOA.jpg alt="optimized velocity magnitude">
<center class=figcaption>Figure 11: Initial velocity magnitude (left) and final (right)</center></p><p><img style=display:inline-block width=49% src=Benchmark_4_K_INITIAL.jpg alt="initial turbulent kinetic energy">
<img style=display:inline-block width=49% src=Benchmark_4_K_NEWUOA.jpg alt="optimized turbulent kinetic energy">
<center class=figcaption>Figure 12: Initial turbulent kinetic energy (left) and final (right)</center></p><p>From figures [11] and [12] above, a direct comparison between the initial and optimal solution can be seen. Of interest is the improvement in flow distribution as seen by the velocity magnitude. To further improve flow uniformity, additional fidelity is needed. This could be accomplished by adding more control points however the solution would become increasingly more expensive. A cage parameterization would be ideal.</p><p>Below the solution convergence can be seen from both the velocity distribution and pressure loss perspectives.</p><p><img style=display:inline-block width=49% src=BENCHMARK_4_CONVERGENCE_P.png alt="optimization solution convergence">
<img style=display:inline-block width=49% src=BENCHMARK_4_CONVERGENCE_SD.png alt="optimization solution convergence">
<center class=figcaption>Figure 13: Solution convergence for pressure loss (left) and flow uniformity (right)</center></p><p>Lastly, the distribution of solutions can be seen below in figure [14]. A wide variety of responses were created from the optimizers with the majority succeeding in improving the performance of the airbox. Of interest is the diverse range that NEWUOA creates in its search for the optimum. This is a positive attribute in that, the search space is completely and evenly filled except near the optimum where there is a concentration of designs.</p><p><img title="airbox design candidates" src=BENCHMARK_4_NEWUOA_PARETO.png alt="airbox design candidates">
<center class=figcaption>Figure 14: Airbox design canidates</center></p><p>The initial airbox and the NEWUOA optimized design can be seen below in figure [15]. One can easily see the differences between the initial and optimized designs.</p><p><img style=display:inline-block width=49% title="airbox shape optimization - initial" alt="airbox shape optimization - initial" src=initial.jpg>
<img style=display:inline-block width=49% title="airbox shape optimization - final" alt="airbox shape optimization - final" src=NEWUOA.jpg>
<center class=figcaption>Figure 15: Optimization results - initial (left), final NEWUOA solution (right)</center></p><p>Although this platform found substantial performance improvements for this Formula Ford airbox, one has to remember that this is a single wall structure and any geometric adjustments will impact both internal and external flow properties. The current optimized design may provide better internal flow conditions but it might also adversely impact the external drag of the vehicle rendering it useless.</p><h2>Conclusion</h2><p>Overall open-source based aerodynamic shape optimization if used correctly can be an extremely powerful design tool. Its performance has been proven, and its application has been demonstrated. Instead of paying tens of thousands of dollars for a single seat of commercial black box mystery, one could simply clone [<a target=_blank rel="noopener noreferrer" href=https://github.com/nathanrooy/BlenderFOAM>this repo</a>] and begin optimizing!</p><h2>Acknowledgements</h2><p>Special thanks once again to Paolo, and Eugene at <a target=_blank rel="noopener noreferrer" href=https://engys.com/>Engys</a> for helping me while I completed my thesis.</p><h2>References</h2><div class=footnotes><hr><ol><li id=fn:fn1>Joshi, P., Meyer, M., and DeRose, T., <a href=https://graphics.pixar.com/library/HarmonicCoordinatesB/paper.pdf target=_blank rel="noopener noreferrer"><i>Harmonic Coordinates for Character Articulation</i></a> (Pixar Technical Memo, 2007)
<a class=footnote-return href=#fnref:fn1><sup>[return]</sup></a></li></ol></div></div><div class=post-hr><hr></div></div><div class=footer><center>&copy; <a href=/about>Nathan A. Rooy</a>.<br>Built with <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>.
Powered by <a target=_blank rel="noopener noreferrer" href=http://www.github.com>GitHub</a></center></div></body></html>