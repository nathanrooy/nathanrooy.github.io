<html lang=en><head><meta charset=utf-8><title>Nathan Rooy</title><meta content="Nathan Rooy" name=author><meta content=en name=language><meta content="width=device-width,minimum-scale=1" name=viewport><meta content=nathan.fun property=og:site_name><meta content=nathan.fun property=twitter:domain><meta content=article property=og:type><meta content=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/ property=og:url><meta content=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/ name=twitter:url><meta content="Nathan A. Rooy" name=copyright><meta content=summary_large_image name=twitter:card><meta content="simulated annealing,shape optimization,tsp,python,tutorial" name=keywords><meta content="Effective Simulated Annealing with Python" name=twitter:title><meta content="Effective Simulated Annealing with Python" property=og:title><meta content="Effective Simulated Annealing with Python" name=description><meta content="Effective Simulated Annealing with Python" name=twitter:description><meta content="Effective Simulated Annealing with Python" property=og:description><meta content=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/u2.png name=twitter:image><meta content=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/u2.png property=og:image><meta content=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/u2.png name=thumbnail><link title="Nathan Rooy" href=https://nathan.fun/index.xml rel=alternate type=application/rss+xml><link href=/favicon/favicon.png rel=icon type=image/png><link as=font crossorigin href=/fonts/figtree-v1-latin-regular.woff2 rel=preload type=font/woff2><link href=https://nathan.fun/posts/2020-05-14/simulated-annealing-with-python/ rel=canonical><link href=https://raw.githubusercontent.com/nathanrooy/feedly-opml-archiver/refs/heads/main/feedly.opml rel=blogroll type=text/xml><script data-domain=nathan.fun defer src=https://plausible.io/js/script.tagged-events.js></script><style>:root{--main-text-color:#222;--main-text-weight:400;--text-bold:600;--font-family:"Figtree",sans-serif;--background-light:#f5f5f5;--link-text-color:#0955b5;--dark-text-color:#999}html{font-size:16px}body{-webkit-font-smoothing:antialiased;font-family:var(--font-family);color:var(--main-text-color);font-weight:var(--main-text-weight)}.wrapper{max-width:660px;margin:6rem auto 0;padding:1rem}@media only screen and (width<=750px){.wrapper{margin-top:2.5rem;margin-left:0}}a{color:var(--link-text-color);text-decoration:none}::selection{text-shadow:none;background:#fff9c4}img{max-width:100%;margin:1.5em auto;display:block}@font-face{font-family:Figtree;font-style:normal;font-weight:400;font-display:swap;src:url(/fonts/figtree-v1-latin-regular.eot);src:local(""),url(/fonts/figtree-v1-latin-regular.eot?#iefix)format("embedded-opentype"),url(/fonts/figtree-v1-latin-regular.woff2)format("woff2"),url(/fonts/figtree-v1-latin-regular.woff)format("woff"),url(/fonts/figtree-v1-latin-regular.ttf)format("truetype"),url(/fonts/figtree-v1-latin-regular.svg#Figtree)format("svg")}@font-face{font-family:Figtree;font-style:normal;font-weight:600;font-display:swap;src:url(/fonts/figtree-v1-latin-600.eot);src:local(""),url(/fonts/figtree-v1-latin-600.eot?#iefix)format("embedded-opentype"),url(/fonts/figtree-v1-latin-600.woff2)format("woff2"),url(/fonts/figtree-v1-latin-600.woff)format("woff"),url(/fonts/figtree-v1-latin-600.ttf)format("truetype"),url(/fonts/figtree-v1-latin-600.svg#Figtree)format("svg")}.wrapper{padding-bottom:8rem}.markdown ol li{padding-bottom:.75em}p{letter-spacing:.01rem;word-spacing:.025rem;margin:0 0 1rem;font-size:1rem;line-height:1.7rem}h1{font-weight:var(--main-text-weight);color:var(--main-text-color);font-size:2.3rem;line-height:2.64rem}h2{font-size:1.2rem;font-weight:var(--text-bold);margin-bottom:.3em}*+h2{padding-top:2rem}table{letter-spacing:-.01em;border-collapse:collapse;width:100%;margin-top:2em;margin-bottom:2em;font-size:14px;line-height:1.2rem}table th{text-align:left}table thead{border-bottom:1px solid var(--main-text-color);line-height:1.4em}hr{height:1px;color:var(--main-text-color);background-color:var(--main-text-color);border:none;margin:4rem 0}@media only screen and (width>=751px){#burger{padding-top:2rem;padding-left:2rem}}@media only screen and (width<=750px){#burger{padding-top:1rem;padding-left:1rem}}#burger{font-family:var(--font-family);color:#a9a9a9;font-size:1.5rem;font-weight:400}#burger a{padding-right:.8rem;display:inline-block}#burger label{cursor:pointer}#nav-icons{padding-left:.8rem}#nav-icons svg{max-height:20px;color:var(--main-text-color);margin-bottom:-.05rem}#l1-val{position:relative;top:-.12rem}#l2-val{padding-left:.1rem;padding-right:.1rem;position:relative;top:-.2rem}#burger-cbox{display:none}#label-1{display:inline-block}#label-2,#burger-cbox:not(:checked)~#nav-icons{display:none}.figcaption{padding-bottom:1rem;font-size:.8rem}.post .post-header{margin-bottom:2.5rem}.post .post-header .title{margin:0}.math-block{margin-top:2rem;margin-bottom:2rem}mtext{position:absolute;right:0}.highlight pre{word-wrap:normal;white-space:pre;padding:20px;overflow:auto;background-color:#0000!important}.highlight{background:0 0;background-color:var(--background-light)}.markdown .footnotes ol{counter-reset:item;width:fit-content;color:var(--dark-text-color);padding-left:0;padding-right:0}.markdown .footnotes li{padding-bottom:0;display:block}.markdown .footnotes li:before{content:counter(item)". ";counter-increment:item;width:2em;display:inline-block;position:absolute}.markdown .footnotes li p{padding-left:2rem;line-height:1.25rem}.markdown .footnotes li a{color:var(--dark-text-color)}</style><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ rel=stylesheet></head><body><div class=header><nav><div id=burger><input id=burger-cbox type=checkbox><label for=burger-cbox id=label-1><span>[</span><span id=l1-val>+</span><span>]</span></label><label for=burger-cbox id=label-2><span>[</span><span id=l2-val>x</span><span>]</span></label><div id=nav-icons><a class="plausible-event-name=burger+home" aria-label=Home href=/ style=padding-right:.7rem><svg class="feather feather-home" viewbox="0 0 24 24" fill=none height=24 id=home-icon stroke=currentcolor stroke-linecap=round stroke-linejoin=round stroke-width=1 width=24><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></a><a class="plausible-event-name=burger+reading" aria-label=Reading href=/reading><svg viewbox="0 0 23.809855 18.892912" height=24 id=svg5 width=24><defs id=defs2></defs><g id=layer1 transform=translate(-6.352941,-30.26865)><g id=g39 transform=matrix(0.26458333,0,0,0.26458333,5.0300244,26.48677)><path d="m92.22 22.9v59C74.24 76.35 61.26 78.85 54.73 81.04 59.2 76.64 68.54 70.55 84.16 74.14l1.69.39V21.42c2.17.29 4.3.77 6.37 1.48z" class=st0 id=path11></path><path d="M45.24 81.04C38.73 78.85 25.74 76.35 7.77 81.9v-59c2.06-.71 4.2-1.19 6.37-1.48v53.11l1.68-.39c15.61-3.58 24.96 2.5 29.42 6.9z" class=st0 id=path13></path><polygon points="48.86,85.63 48.82,85.58 48.91,85.63" id=polygon15></polygon><polygon points="51.17,85.58 51.13,85.63 50,85.63 51.09,85.62" id=polygon17></polygon><path d="m94.09 20.63c-2.68-1-5.45-1.65-8.24-2.02v-2.94l-1.08-.24c-17.8-4.09-28.32 3.81-32.9 8.68-.81.87-1.44 1.63-1.88 2.22C49.54 25.74 48.91 24.98 48.1 24.11c-4.58-4.87-15.11-12.76-32.9-8.68l-1.07.24v2.94c-2.8.38-5.57 1.02-8.24 2.02L5 20.97V85.7l1.81-.61c13.49-4.49 24.13-4.16 30.68-3.08 7.09 1.15 11.05 3.4 11.09 3.42l.23.14.09.06H50l1.09-.01.08-.05.23-.14c.05-.02 4-2.27 11.09-3.42 6.55-1.08 17.19-1.41 30.68 3.08l1.82.61V20.97zM7.78 81.89v-59c2.06-.71 4.2-1.19 6.37-1.48v53.11l1.68-.39c15.61-3.58 24.95 2.5 29.42 6.9-6.52-2.18-19.5-4.68-37.47.86zm40.76-1.3c-4.19-4.66-14.29-12.83-31.63-9.5v-53.2c11.11-2.28 18.93.38 24.02 3.66 2.6 1.68 4.48 3.52 5.71 4.95 1.14 1.32 1.73 2.28 1.82 2.43l.08.15zm2.76.17V29.34l.24-.4c.09-.16.68-1.12 1.82-2.44 1.23-1.43 3.11-3.27 5.71-4.94 5.08-3.29 12.91-5.95 24.02-3.67v53.2C65.54 67.72 55.4 76.13 51.3 80.76zm40.92 1.13C74.24 76.34 61.26 78.84 54.73 81.03 59.2 76.63 68.54 70.54 84.16 74.13l1.69.39v-53.1c2.16.29 4.3.77 6.37 1.48z" id=path19></path></g></g><style id=style9>.st0{fill:none}</style></svg> </a><a aria-label="NYC Bike Exploring" class="plausible-event-name=burger+nycbike" href=/bike-exploring/nyc style=margin-left:.4rem><svg viewbox="0 0 91.5 52.5" height=24 width=32><g transform=matrix(-1,0,0,1,95.8,-23.9)><path d="m78 40.6c-3.8.0-7.3 1.2-10.2 3.2l-7.4-9.4 2.9-8.5H67c.6.0 1-.4 1-1s-.4-1-1-1H54.8c-.6.0-1 .4-1 1s.4 1 1 1h6.3l-2.3 6.7c-.2-.2-.4-.3-.7-.3H32l2.2-6.4h5.7c.6.0 1-.4 1-1s-.4-1-1-1h-6.4c-.4.0-.8.3-.9.7l-5.7 16.8c-1.5-.4-3.1-.7-4.8-.7-9.8.0-17.8 8-17.8 17.8s8 17.8 17.8 17.8 17.8-8 17.8-17.8c0-7.5-4.6-13.9-11.2-16.5l2.6-7.6 19 24.4c.1.3.3.6.6.7.1.0.2.1.3.1h.1 8.9c.5 9.4 8.3 16.8 17.8 16.8 9.8.0 17.8-8 17.8-17.8s-8-18-17.8-18zM37.8 58.4c0 8.7-7.1 15.8-15.8 15.8S6.2 67.1 6.2 58.4 13.3 42.6 22 42.6c1.4.0 2.8.2 4.1.6L21 58.1c-.2.5.1 1.1.6 1.3.1.0.2.1.3.1.4.0.8-.3.9-.7l5.1-14.9c5.9 2.2 9.9 7.9 9.9 14.5zm29.7-11.8L76 57.4H62.2c.3-4.3 2.2-8.1 5.3-10.8zm-16.7 9.6-17.1-22h24l.4.5zm1.8 1.2 7.1-20.8 6.6 8.4c-3.5 3.1-5.7 7.4-6 12.4zM78 74.2c-8.4.0-15.2-6.6-15.8-14.8H78c.4.0.7-.2.9-.6.2-.3.1-.8-.1-1.1L69 45.4c2.5-1.8 5.6-2.8 8.9-2.8 8.7.0 15.8 7.1 15.8 15.8s-7 15.8-15.7 15.8z"></path></g></svg></a><a class="plausible-event-name=burger+about" aria-label=About href=/about><svg class="feather feather-user" viewbox="0 0 24 24" fill=none height=24 id=about-icon stroke=currentcolor stroke-linecap=round stroke-linejoin=round stroke-width=1 width=24><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"></path><circle cx=12 cy=7 r=4></circle></svg> </a><a class="plausible-event-name=burger+rss" aria-label=RSS href=/index.xml><svg class="feather feather-rss" viewbox="0 0 30 24" fill=none height=24 id=rss-icon stroke=#444 stroke-linecap=round stroke-linejoin=round stroke-width=1.5 width=24><path d="M4 11a9 9 0 019 9"></path><path d="M4 4a16 16 0 0116 16"></path><circle cx=5 cy=19 r=1></circle></svg></a></div></div></nav></div><div class="wrapper post"><div class=post-header><h1 class=title>Effective Simulated Annealing with Python</h1></div><hr><div class=markdown><h2 id=introduction>Introduction</h2><p>I use some form of optimization on a daily basis, whether it’s for work or personal projects. Something else I do on a daily basis is avoid <a href=https://en.wikipedia.org/wiki/Simulated_annealing target=_blank>simulated annealing</a>. I’ve always associated simulated annealing with inefficiency. Yes, it’s a global optimizer, but at what cost? In most situations I’ve been able to achieve optimal or near-optimal results in a substantially quicker time using various other methods (<a href=https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/ terget=_blank>particle swarm</a>, <a href=https://nathanrooy.github.io/posts/2017-08-27/simple-differential-evolution-with-python/ target=_blank>genetic/evolutionary</a>, etc…). So what’s the deal?</p><p>Over the winter I decided to invest some time in actually understanding this method and forced myself into using it. I learned a lot and actually use it from time to time now. I decided to document my learnings in the form of this tutorial to my future self and anyone else interested in simulated annealing.</p><h2 id=background>Background</h2><p>Simulated annealing is a probabilistic optimization scheme which guarantees convergence to the global minimum given sufficient run time. It’s loosely based on the idea of a <a href=https://en.wikipedia.org/wiki/Annealing_(metallurgy) target=_blank>metallurgical annealing</a> in which a metal is heated beyond its critical temperature and cooled according to a specific schedule until it reaches its minimum energy state. This controlled cooling regiment results in unique material properties useful for specific applications.</p><p>At its core, simulated annealing is based on equation [1] which represents the probability of jumping to the next energy level. Within the context of simulated annealing, <i>energy level</i> is simply the current value of whatever function that’s being optimized.</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>P</mi><mo stretchy=false>(</mo><msub><mi>e</mi><mi>c</mi></msub><mo separator=true>,</mo><msub><mi>e</mi><mi>n</mi></msub><mo separator=true>,</mo><mi>T</mi><mo stretchy=false>)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi mathvariant=normal>Δ</mi><mi>E</mi><mi mathvariant=normal>/</mi><mi>T</mi></mrow></msup></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> P(e_c, e_n, T) = e^{-\Delta E/T} \tag{1} </annotation></semantics></math></span></div><p style=margin:0><b>Nomenclature:</b></p><style>.nomenclature p{margin:0;padding:0}</style><div class=nomenclature style=margin-left:2rem;padding-bottom:1rem;font-size:16px><div style=align-items:center;padding-bottom:.5rem;display:flex><div style=flex:1;max-width:10%><p><span class=katex><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>e</mi><mi>c</mi></msub></mrow><annotation encoding=application/x-tex> e_c </annotation></semantics></math></span></p></div><div>energy at current state</div></div><div style=align-items:center;padding-bottom:.5rem;display:flex><div style=flex:1;max-width:10%><p><span class=katex><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>e</mi><mi>n</mi></msub></mrow><annotation encoding=application/x-tex> e_n </annotation></semantics></math></span></p></div><div>energy at proposed neighbor site</div></div><div style=align-items:center;padding-bottom:.5rem;display:flex><div style=flex:1;max-width:10%><p><span class=katex><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi mathvariant=normal>Δ</mi><mi>E</mi></mrow><annotation encoding=application/x-tex> \Delta E </annotation></semantics></math></span></p></div><div>change in energy between current state and proposed neighbor state</div></div><div style=align-items:center;padding-bottom:.5rem;display:flex><div style=flex:1;max-width:10%><p><span class=katex><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>T</mi></mrow><annotation encoding=application/x-tex> T </annotation></semantics></math></span></p></div><div>current system temperature</div></div></div><p>The main loop for simulated annealing consists of generating <i>neighbor candidates</i> which are just potential solutions which are then randomly accepted based on an ever increasingly more stringent threshold (Equation [1]).</p><pre tabindex=0><code>0)  # initialize
    t_current = t_start
    s_current = x0
    s_best = x0

1)  # main optimization loop
    while t_current > t_min
        1.A) generate neighbor candidate -> s_new
        1.B) if P(E(s_current), E(s_new), T) >= random(0,1)
            s_current = s_new
        1.C) if E(s_new) &lt; E(s_best)
            s_best = s_new
        1.D) update t_current
      
2)  # end
    output results
</code></pre><p>Although these equations appear simple, there’s actually a few interesting things going on. To point out the obvious, ΔE is positive for any transition resulting in a drop in energy (cost function improvement). Therefor the probability of accepting a lower energy state is 100%, while accepting a worse energy state is a non-zero value that depends on the size of the energy increase and the current system temperature. This also means that the ability to jump to a worse energy level is a very real possibility (which is actually a good thing).</p><p>When the annealing process first begins, the temperature is high and the acceptance criteria for a new neighbor candidate is relaxed. This means the peaks and valleys of the energy landscape are largely ignored resulting in a process not unlike a random walk. Bouncing aimlessly between high and low energy levels might seem counterproductive, however there is a method to this madness. It’s this erratic behavior that drives exploration of the search space, thus enabling it to find the global minimum. As the temperature is slowly cooled the acceptance criteria begins to narrow and the likelihood of transitioning to a neighbor candidate with a larger energy difference drops. At this point, simulated annealing is acting in a way which resembles stochastic gradient decent. The focus is centered around improvements rather than exploration and will <i>generally</i> follow a path of constant decent but may still jump around. As the system approaches its minimum energy state, only the smallest deviations in energy are accepted. This behavior is analogous to gradient decent in that it’s limited to just the local search space and driven entirely by solution improvement.</p><table><thead><tr><th>temperature</th><th>approx. method</th><th>mode</th></tr></thead><tbody><tr><td>high</td><td>random walk</td><td>global exploration</td></tr><tr><td>med</td><td>stochastic gradient decent</td><td>improvement focused</td></tr><tr><td>low</td><td>gradient decent</td><td>local search / exploit</td></tr></tbody></table><p>Balancing the transition phase between a global optimizer exploring the search space and a local optimizer exploiting only what’s in front is critical to achieving good results with simulated annealing. Using an aggressive cooling schedule on a highly multi-modal energy landscape can result in a solution frozen into a local minima, unable to escape to a lower energy level further away. Using a slower cooling schedule, will reduce the chances of getting trapped at the expense of increased computational requirements.</p><p>The simplicity of simulated annealing becomes further evident from its implementation in code below:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#09f;font-style:italic># begin optimizing</span>
</span></span><span style=display:flex><span>self<span style=color:#555>.</span>step, self<span style=color:#555>.</span>accept <span style=color:#555>=</span> <span style=color:#f60>1</span>, <span style=color:#f60>0</span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>while</span> self<span style=color:#555>.</span>step <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>step_max <span style=color:#000;font-weight:700>and</span> self<span style=color:#555>.</span>t <span style=color:#555>>=</span> self<span style=color:#555>.</span>t_min:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># get neighbor</span>
</span></span><span style=display:flex><span>    proposed_neighbor <span style=color:#555>=</span> self<span style=color:#555>.</span>get_neighbor()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># check energy level of neighbor</span>
</span></span><span style=display:flex><span>    E_n <span style=color:#555>=</span> self<span style=color:#555>.</span>cost_func(proposed_neighbor)
</span></span><span style=display:flex><span>    dE <span style=color:#555>=</span> E_n <span style=color:#555>-</span> self<span style=color:#555>.</span>current_energy
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># determine if we should accept the current neighbor</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> random() <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>safe_exp(<span style=color:#555>-</span>dE <span style=color:#555>/</span> self<span style=color:#555>.</span>t):
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>current_energy <span style=color:#555>=</span> E_n
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>current_state <span style=color:#555>=</span> proposed_neighbor[:]
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>accept <span style=color:#555>+=</span> <span style=color:#f60>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># check if the current neighbor is best solution so far</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> E_n <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>best_energy:
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>best_energy <span style=color:#555>=</span> E_n
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>best_state <span style=color:#555>=</span> proposed_neighbor[:]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># update some stuff</span>
</span></span><span style=display:flex><span>    self<span style=color:#555>.</span>t <span style=color:#555>=</span> self<span style=color:#555>.</span>update_t(self<span style=color:#555>.</span>step)
</span></span><span style=display:flex><span>    self<span style=color:#555>.</span>step <span style=color:#555>+=</span> <span style=color:#f60>1</span>
</span></span></code></pre></div><p>Throughout this tutorial, the code examples shown represent the bulk of the important stuff. I did however omit some methods, and non-critical code in the interest of readability. The full code can be viewed [<a href=https://github.com/nathanrooy/simulated-annealing/blob/master/simulated_annealing/sa.py target=_blank>here</a>] or easily installed via the following:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-sh data-lang=sh><span style=display:flex><span>pip install git+https://github.com/nathanrooy/simulated-annealing
</span></span></code></pre></div><p>Additionally, the example cases in the form of <a href=https://jupyter.org/ target=_blank>Jupyter notebooks</a> can be found [<a href=https://github.com/nathanrooy/simulated-annealing/tree/master/examples target=_blank>here</a>]</p><h2 id=implementation---combinatorial>Implementation - Combinatorial</h2><p>What better way to start experimenting with simulated annealing than with the combinatorial classic: the <a href=https://en.wikipedia.org/wiki/Travelling_salesman_problem target=_blank>traveling salesman problem</a> (TSP). After all, SA was literally created to solve this problem.</p><p>The first thing we need to sort out is how we’ll generate neighbor candidates. Luckily for combinatorial problems such as TSP, this is super easy. Given the <code>current_state</code> at iteration i, which is nothing more than a list of values representing nodes in the salesman’s path, we’re going to randomly swap two of them. Since this will be contained within the main <code>minimize</code> class, this becomes a simple method we’ll call <code>move_combinatorial</code> and can be seen below.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>move_combinatorial</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#c30>'''
</span></span></span><span style=display:flex><span><span style=color:#c30>    Swaps two random nodes along a path
</span></span></span><span style=display:flex><span><span style=color:#c30>    '''</span>
</span></span><span style=display:flex><span>    p0 <span style=color:#555>=</span> randint(<span style=color:#f60>0</span>, <span style=color:#366>len</span>(self<span style=color:#555>.</span>current_state)<span style=color:#555>-</span><span style=color:#f60>1</span>)
</span></span><span style=display:flex><span>    p1 <span style=color:#555>=</span> randint(<span style=color:#f60>0</span>, <span style=color:#366>len</span>(self<span style=color:#555>.</span>current_state)<span style=color:#555>-</span><span style=color:#f60>1</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    neighbor <span style=color:#555>=</span> self<span style=color:#555>.</span>current_state[:]
</span></span><span style=display:flex><span>    neighbor[p0], neighbor[p1] <span style=color:#555>=</span> neighbor[p1], neighbor[p0]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> neighbor
</span></span></code></pre></div><p>Now that we have a way of generating neighbor candidates, we need to code out the actual TSP cost function. I went ahead and implemented the simplest version which utilizes a <a href=https://en.wikipedia.org/wiki/Euclidean_distance target=_blank>Euclidean distance</a> metric <code>calc_euclidean</code>. This could very easily be swapped out for something else such as <a href=https://nathanrooy.github.io/posts/2016-09-07/haversine-with-python/ target=_blank>Haversine</a> or <a href=https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/ target=_blank>Vincenty</a> (both available <a href=https://github.com/nathanrooy/spatial-analysis target=_blank>here</a>) if the nodes were instead specified as values of latitude and longitude.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>calc_euclidean</span>(p1, p2):    
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> ((p1[<span style=color:#f60>0</span>] <span style=color:#555>-</span> p2[<span style=color:#f60>0</span>])<span style=color:#555>**</span><span style=color:#f60>2</span> <span style=color:#555>+</span> (p1[<span style=color:#f60>1</span>] <span style=color:#555>-</span> p2[<span style=color:#f60>1</span>])<span style=color:#555>**</span><span style=color:#f60>2</span>)<span style=color:#555>**</span><span style=color:#f60>0.5</span>
</span></span></code></pre></div><p>The main tsp class is as simple as it sounds:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>tsp</span>():
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>def</span> __init__(self, dist_func, close_loop<span style=color:#555>=</span><span style=color:#069;font-weight:700>True</span>):
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>dist_func <span style=color:#555>=</span> dist_func
</span></span><span style=display:flex><span>        self<span style=color:#555>.</span>close_loop <span style=color:#555>=</span> close_loop
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>dist</span>(self, xy):
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># sequentially calculate distance between all tsp nodes</span>
</span></span><span style=display:flex><span>        dist <span style=color:#555>=</span> <span style=color:#f60>0</span>
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(xy)<span style=color:#555>-</span><span style=color:#f60>1</span>): 
</span></span><span style=display:flex><span>            dist <span style=color:#555>+=</span> self<span style=color:#555>.</span>dist_func(xy[i<span style=color:#555>+</span><span style=color:#f60>1</span>], xy[i])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># close the tsp loop by calculating the distance </span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># between the first and last points</span>
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>close_loop:
</span></span><span style=display:flex><span>            dist <span style=color:#555>+=</span> self<span style=color:#555>.</span>dist_func(xy[<span style=color:#f60>0</span>], xy[<span style=color:#555>-</span><span style=color:#f60>1</span>])
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>return</span> dist
</span></span></code></pre></div><p>The tsp cost function can then be initialized in the following way:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>tsp_dist <span style=color:#555>=</span> tsp(dist_func<span style=color:#555>=</span>calc_euclidean, close_loop<span style=color:#555>=</span><span style=color:#069;font-weight:700>True</span>)<span style=color:#555>.</span>dist
</span></span></code></pre></div><p>In the interest of keeping it simple while starting out, let’s create a tsp path in the shape of a circle. Since we know the optimal solution will follow the perimeter, it will be easy to validate.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-Python data-lang=Python><span style=display:flex><span>n_pts <span style=color:#555>=</span> <span style=color:#f60>10</span>
</span></span><span style=display:flex><span>dr <span style=color:#555>=</span> (<span style=color:#f60>2</span> <span style=color:#555>*</span> pi) <span style=color:#555>/</span> n_pts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x0 <span style=color:#555>=</span> []
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,n_pts):
</span></span><span style=display:flex><span>    radians <span style=color:#555>=</span> dr <span style=color:#555>*</span> i  
</span></span><span style=display:flex><span>    x0<span style=color:#555>.</span>append([cos(radians), sin(radians)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>shuffle(x0)
</span></span></code></pre></div><p>With 10 points, the optimal energy (path length in this case) is ~6.1803 (just under 2π) but jumps to 15.3540 because of the random shuffle. Now, everything is in place and we can begin optimizing.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
</span></span><span style=display:flex><span>    tsp_dist,
</span></span><span style=display:flex><span>    x0,
</span></span><span style=display:flex><span>    opt_mode<span style=color:#555>=</span><span style=color:#c30>'combinatorial'</span>,
</span></span><span style=display:flex><span>    step_max<span style=color:#555>=</span><span style=color:#f60>750</span>,
</span></span><span style=display:flex><span>    t_max<span style=color:#555>=</span><span style=color:#f60>4</span>,
</span></span><span style=display:flex><span>    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>) 
</span></span></code></pre></div><p>Once finished, we can view the results by calling the <code>results()</code> method:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>opt<span style=color:#555>.</span>results()
</span></span></code></pre></div><p>Which will yield the following (usually):</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#555>+------------------------</span> RESULTS <span style=color:#555>-------------------------+</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cooling sched<span style=color:#555>.</span>: linear
</span></span><span style=display:flex><span>      opt<span style=color:#555>.</span>mode: combinatorial
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  initial temp: <span style=color:#f60>4</span>
</span></span><span style=display:flex><span>    final temp: <span style=color:#f60>0.000000</span>
</span></span><span style=display:flex><span>     <span style=color:#366>max</span> steps: <span style=color:#f60>750</span>
</span></span><span style=display:flex><span>    final step: <span style=color:#f60>750</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  final energy: <span style=color:#f60>6.180340</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#555>+--------------------------</span> END <span style=color:#555>---------------------------+</span>
</span></span></code></pre></div><p>We can access the optimal solution via:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>opt<span style=color:#555>.</span>best_state
</span></span></code></pre></div><p>And then plot it to further validate that we have indeed achieved the global minimum.</p><img alt="circular traveling salesman problem" src=tsp_circle_compare.svg><center class=figcaption>Initial path (left), and optimized path (right)</center><p>In order to get a better understanding of how simulated annealing converges onto the solution for this example, I went ahead and ran it 1000 times and consolidated the results into the mean and 90% confidence intervals. The first plot below shows the current state of the optimizer. We can see that it quickly accrues some easy wins before settling ito a gently descending trajectory. We can also see that towards the end of the run, the confidence interval begins to shrink indicating a temperature level which prioritizes local improvements over exploration.</p><img alt="simulated annealing optimization - current state" src=tsp_circle_current_state.svg><p>The last plot below, shows the best solution achieved throughout the optimization process. We can see that early on, simulated annealing is able to quickly capture the low hanging fruit during the exploration phase. After the quick gains, progress slows while it continues to search the energy landscape until finally converging on the optimal solution.</p><img alt="simulated annealing optimization - best state" src=tsp_circle_best_state.svg><p>Okay I can’t resist, lets swap out that distance function for something a little more fun/useful. Let’s say we want to bike to every one of our favorite breweries in Cincinnati in the shortest distance possible (this is what initially piqued my interest in simulated annealing 🚴‍♂️🍺). In this situation, since we’re limited to streets and bike paths we’ll need to use network distance. However, since network distance relies on <a href=https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm target=_blank>Dijkstra’s algorithm</a> to find the shortest path between two nodes in a graph, it requires more compute power than the simpler Euclidean distance. We could keep it simple by coding out Dijkstra’s algorithm and pairing that with the <a href=https://en.wikipedia.org/wiki/OpenStreetMap target=_blank>OpenStreetMap</a> network graph but we’d be stuck calling the function a bunch of times for the same set of points. This is both lazy and inefficient. Instead, let’s enumerate all origin-destination pairs and pre-compute the distances. We can then save the results in the form of a distance matrix which will act as a sort of lookup table allowing for super quick function calls. This results in a new distance function as seen below:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>calc_dict</span>(p1, p2, dist_dict<span style=color:#555>=</span>dist_dict):   
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> dist_dict[p1,p2]
</span></span></code></pre></div><p>Which we can then use to initialize the updated tsp cost function:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>tsp_bike <span style=color:#555>=</span> tsp(dist_func<span style=color:#555>=</span>calc_dict, close_loop<span style=color:#555>=</span><span style=color:#069;font-weight:700>True</span>)<span style=color:#555>.</span>dist
</span></span></code></pre></div><p>Just as before, we’ll call the <code>minimize</code> method from our simulated annealing class to begin the optimization.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
</span></span><span style=display:flex><span>    tsp_bike,
</span></span><span style=display:flex><span>    x0,
</span></span><span style=display:flex><span>    opt_mode<span style=color:#555>=</span><span style=color:#c30>'combinatorial'</span>,
</span></span><span style=display:flex><span>    step_max<span style=color:#555>=</span><span style=color:#f60>1000</span>, 
</span></span><span style=display:flex><span>    t_max<span style=color:#555>=</span><span style=color:#f60>50</span>, 
</span></span><span style=display:flex><span>    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>) 
</span></span></code></pre></div><p>Since the breweries are listed in an arbitrary order, the initial energy of the system is roughly 84481.27 which represents the total circuit length in meters (52.49 miles). Below is the initial state (red dots indicate brewery locations while the red line is the travel path):</p><picture><source srcset=tsp_cincy_initial.webp type=image/webp><source srcset=tsp_cincy_initial.png type=image/png><img alt="traveling salesman problem - Cincinnati breweries - initial" src=tsp_cincy_initial.png></picture><p>After optimization, the final state has an energy of roughly 51104.00 (31.75 miles) and can be seen below. I ran this example several times with varying levels of <code>t_max</code>, <code>t_min</code> and <code>max_iters</code> and they all converged to the same solution the majority of the time indicating that the energy landscape for this case is multi-modal but fairly smooth.</p><picture><source srcset=tsp_cincy_final.webp type=image/webp><source srcset=tsp_cincy_final.png type=image/png><img alt="traveling salesman problem - Cincinnati breweries - final" src=tsp_cincy_final.png></picture><h2 id=implementation---continuous>Implementation - Continuous</h2><p>Now for the fun stuff; continuous real valued problems! Let’s say you’re an engineer working within Lockheed Skunk Works and aerospace legend <a href=https://en.wikipedia.org/wiki/Kelly_Johnson_(engineer) target=_blank>Kelly Johnson</a> stops by your desk and requests an airfoil for a new <a href=https://en.wikipedia.org/wiki/Lockheed_U-2 target=_blank>high altitude reconnaissance aircraft</a> code named <i>Dragon Lady</i>.<sup id=fnref:1><a class=footnote-ref href=#fn:1 role=doc-noteref>1</a></sup> You’ve got access to the best compute resources the 1950’s has to offer and one day. Time is ticking.</p><picture><source srcset=u2.webp type=image/webp><source srcset=u2.png type=image/png><img alt="Dragon Lady aka the Lockheed U2" src=u2.png></picture><p>Ignoring the vast majority of constraints that are usually at play in a situation such as this, we’re going to instead focus on a single objective: maximizing the ratio of lift to drag. For this, we’ll start with the NACA 0012. This is a symmetric airfoil which means it has no <a href=https://en.wikipedia.org/wiki/Camber_(aerodynamics) target=_blank>camber</a> and subsequently generates no lift when the <a href=https://en.wikipedia.org/wiki/Angle_of_attack target=_blank>angle of attack</a> (<b>α</b>) is at zero degrees. This will provide a neutral starting point for this exercise.</p><p>The symmetric <a href=https://en.wikipedia.org/wiki/NACA_airfoil target=_blank>NACA 4-digit airfoils</a> are described using a simple formula which is based on the ratio of maximum thickness to <a href=https://en.wikipedia.org/wiki/Chord_(aeronautics) target=_blank>chord length</a>. This is great because it’s simple and easy to implement, but terrible for optimization. How are we going to meaningfully change the shape of the airfoil if we only have this single ratio? Sure, we could use a more advanced NACA formulation but in the end, we’re still going to limit ourselves. Instead, let’s parameterize our airfoil using <a href=https://en.wikipedia.org/wiki/B%C3%A9zier_curve target=_blank>Bézier curves</a>. Because this is a tutorial on simulated annealing and not aerodynamic shape optimization, I’ll spare all the juicy details for another day.</p><p>Long story short, the airfoil has been converted from a series of points into a parametric curve through the use of a composite quadratic Bézier curve (more on that <a href=https://nathanrooy.github.io/posts/2016-09-14/airfoil-manipulation-via-bezier-curves-with-python/ target=_blank>here</a>). What this means, is that we can now morph the shape of this airfoil using a series of control points to generate an infinite number of different variations. Perfect for optimization.</p><img alt="parametric naca 0012 airfoil" src=bezier_naca0012.svg><p>As seen from above, the airfoil has been parameterized with 10 control points, however the two at the trailing edge are fixed and the two leading edge control points can only move along the y-axis. The rest can move freely in both the x, and y directions. What this means is that we have a system with 13 degrees of freedom which is plenty enough for this task. Adding more control points would enable a higher level of fidelity but at the expense of a larger search space making optimization a more difficult.</p><p>Now that we have a parameterized airfoil we need to two more things: a way of generating neighbor candidates and a cost function. The neighbor generation for this example will remain simple, let’s just randomly perturb each control point by a small random amount. In code, this looks like this:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>move_continuous</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># perturb current state by a random amount limited by the damping factor</span>
</span></span><span style=display:flex><span>    neighbor <span style=color:#555>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>for</span> item <span style=color:#000;font-weight:700>in</span> self<span style=color:#555>.</span>current_state:
</span></span><span style=display:flex><span>        neighbor<span style=color:#555>.</span>append(item <span style=color:#555>+</span> ((random() <span style=color:#555>-</span> <span style=color:#f60>0.5</span>) <span style=color:#555>*</span> self<span style=color:#555>.</span>damping))
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># clip to upper and lower bounds</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>bounds:            
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(neighbor)):
</span></span><span style=display:flex><span>            x_min, x_max <span style=color:#555>=</span> self<span style=color:#555>.</span>bounds[i]
</span></span><span style=display:flex><span>            neighbor[i] <span style=color:#555>=</span> <span style=color:#366>min</span>(<span style=color:#366>max</span>(neighbor[i], x_min), x_max)  
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> neighbor
</span></span></code></pre></div><p>Note, that I added a simple check that forces the new neighbor candidate to remain within some bounds as optionally specified by the user. Lastly, the cost function consists of nothing more than creating the new airfoil, calculating the aerodynamic forces, and returning the results. Aerodynamic forces will be calculated using <a href=https://web.mit.edu/drela/Public/web/xfoil/ target=_blank>XFOIL</a> which is based on a linear-strength vortex panel method.<sup id=fnref:2><a class=footnote-ref href=#fn:2 role=doc-noteref>2</a></sup><sup>,</sup><sup id=fnref:3><a class=footnote-ref href=#fn:3 role=doc-noteref>3</a></sup> Given the time period and compute limitations, panel methods would have been the likely approach taken rather than a <a href=https://en.wikipedia.org/wiki/Computational_fluid_dynamics target=_blank>CFD</a> based approach.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>cost_function</span>(x, x_coords<span style=color:#555>=</span>x_cos):
</span></span><span style=display:flex><span>    airfoil_file <span style=color:#555>=</span> <span style=color:#c30>'airfoil.txt'</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># munge x-vector into bezier format</span>
</span></span><span style=display:flex><span>        control_pts <span style=color:#555>=</span> munge_ctlpts(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># generate new airfoil</span>
</span></span><span style=display:flex><span>        curve <span style=color:#555>=</span> bezier_airfoil(x_coords, control_pts)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># output airfoil to csv</span>
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>with</span> <span style=color:#366>open</span>(airfoil_file,<span style=color:#c30>'w'</span>) <span style=color:#069;font-weight:700>as</span> out_file:
</span></span><span style=display:flex><span>            out_file<span style=color:#555>.</span>write(<span style=color:#c30>'x,y</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>'</span>)
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>for</span> item <span style=color:#000;font-weight:700>in</span> curve:
</span></span><span style=display:flex><span>                out_file<span style=color:#555>.</span>write(<span style=color:#c30>f</span><span style=color:#c30>'</span><span style=color:#a00>{</span>item[<span style=color:#f60>0</span>]<span style=color:#a00>}</span><span style=color:#c30>,</span><span style=color:#a00>{</span>item[<span style=color:#f60>1</span>]<span style=color:#a00>}</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>'</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># run xfoil and collect results</span>
</span></span><span style=display:flex><span>        results_dict <span style=color:#555>=</span> run_xfoil()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic># determine cost</span>
</span></span><span style=display:flex><span>        cost <span style=color:#555>=</span> results_dict[<span style=color:#c30>'cl'</span>] <span style=color:#555>/</span> results_dict[<span style=color:#c30>'cd'</span>]
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>if</span> results_dict[<span style=color:#c30>'cl'</span>] <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>: cost <span style=color:#555>=</span> <span style=color:#f60>0.01</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>except</span>:
</span></span><span style=display:flex><span>        cost <span style=color:#555>=</span> <span style=color:#f60>0.01</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic># remove temp airfoil file</span>
</span></span><span style=display:flex><span>    os<span style=color:#555>.</span>system(<span style=color:#c30>f</span><span style=color:#c30>'rm -rf </span><span style=color:#a00>{</span>airfoil_file<span style=color:#a00>}</span><span style=color:#c30>'</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>1000.0</span> <span style=color:#555>/</span> cost
</span></span></code></pre></div><p>Now, everything is in place and we can begin optimizing (reference the jupyter notebook [<a href=https://github.com/nathanrooy/simulated-annealing/blob/master/examples/airfoil/airfoil.ipynb target=_blank>here</a>] for all the details).</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
</span></span><span style=display:flex><span>    cost_function,
</span></span><span style=display:flex><span>    x0,
</span></span><span style=display:flex><span>    opt_mode<span style=color:#555>=</span><span style=color:#c30>'continuous'</span>,
</span></span><span style=display:flex><span>    step_max<span style=color:#555>=</span><span style=color:#f60>125</span>,
</span></span><span style=display:flex><span>    t_max<span style=color:#555>=</span><span style=color:#f60>2</span>,
</span></span><span style=display:flex><span>    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>,
</span></span><span style=display:flex><span>    damping<span style=color:#555>=</span><span style=color:#f60>0.01</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Because the initial reverse-fitting yielded an airfoil that wasn’t perfectly symmetrical, the initial L/D was slightly less than 0.5, while the optimized airfoil achieved an L/D of just over 100. While running this example, it’s fairly common to get an airfoil with an L/D nearing 200 however these tend to be structurally unfeasible and suffer from highly unfavorable stability characteristics. So what you see below is actually not a global optimum but a slightly more realistic local optimum.</p><img alt="optimized airfoil via simulated annealing" src=final_airfoil_compare.svg><p>Given that XFOIL is able to calculate all useful aerodynamic forces, it would be trivial to incorporate additional constraints such as stability or lift across a range of <a href=https://en.wikipedia.org/wiki/Reynolds_number target=_blank>Reynolds numbers</a>.</p><h2 id=cooling-schedules>Cooling Schedules</h2><p>The concept of a cooling schedule is a big part of simulated annealing and until now I’ve purposely left out how temperature reduction actually occurs. They come in a number of different flavors and the choice of which cooling schedule to use is considered an important decision.<sup id=fnref:4><a class=footnote-ref href=#fn:4 role=doc-noteref>4</a></sup> There exists a whole body of research on cooling schedules each with their own advantages and disadvantages. Some such as <i>multiplicative monotonic cooling schedules</i> rely on nothing more than the starting temperature (T_max), the current step (k), and a manually set constant alpha.</p><p>linear multiplicative</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><mi>α</mi><mi>k</mi></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = T_{max} - \alpha k \tag{3} </annotation></semantics></math></span></div><p>natural log exponential multiplicative</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><msup><mi>α</mi><mi>k</mi></msup></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(4)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = T_{max} \alpha^{k} \tag{4} </annotation></semantics></math></span></div><p>logarithmic multiplicative</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><mfrac><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mrow><mn>1</mn><mo>+</mo><mi>α</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=false>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=false>)</mo></mrow></mfrac></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = \frac{T_{max}}{1 + \alpha log(k+1)} \tag{5} </annotation></semantics></math></span></div><p>quadratic multiplicative</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><mfrac><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mrow><mn>1</mn><mo>+</mo><mi>α</mi><msup><mi>k</mi><mn>2</mn></msup></mrow></mfrac></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(6)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = \frac{T_{max}}{1 + \alpha k^2} \tag{6} </annotation></semantics></math></span></div><p>On the other hand, <i>additive monotonic cooling schedules</i> depend on two additional parameters: the total number of steps <code>n</code> and the final temperature (t_min).</p><p>linear additive:</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mo stretchy=false>(</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy=false>)</mo><mrow><mo fence=true>(</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><mi>n</mi></mfrac><mo fence=true>)</mo></mrow></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(7)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{n - k}{n} \right) \tag{7} </annotation></semantics></math></span></div><p>exponential additive:</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mo stretchy=false>(</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy=false>)</mo><mrow><mo fence=true>(</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mfrac><mrow><mn>2</mn><mi>ln</mi><mo>⁡</mo><mo stretchy=false>(</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy=false>)</mo></mrow><mi>n</mi></mfrac><mrow><mo fence=true>(</mo><mi>k</mi><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi><mo fence=true>)</mo></mrow></mrow></msup></mrow></mfrac><mo fence=true>)</mo></mrow></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(8)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{1}{1+e^{\frac{2 \ln (T_{max}-T_{min})}{n} \left(k-\frac{1}{2}n \right)}} \right) \tag{8} </annotation></semantics></math></span></div><p>quadratic additive:</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mtable width=100%><mtr><mtd width=50%></mtd><mtd><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mo stretchy=false>(</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy=false>)</mo><msup><mrow><mo fence=true>(</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><mi>n</mi></mfrac><mo fence=true>)</mo></mrow><mn>2</mn></msup></mrow></mtd><mtd width=50%></mtd><mtd><mtext>(9)</mtext></mtd></mtr></mtable><annotation encoding=application/x-tex> T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{n - k}{n} \right)^2 \tag{9} </annotation></semantics></math></span></div><p>Lastly, we have the <i>non-monotonic adaptive cooling schedules</i> which involve all previously mentioned parameters as well as an adaptive factor based on the difference between the current state and the best state achieved thus far.</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>T</mi><mo stretchy=false>(</mo><mi>k</mi><mo stretchy=false>)</mo><mo>=</mo><mi>μ</mi><msub><mi>T</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex> T(k) = \mu T_k </annotation></semantics></math></span></div><p>Where:</p><div class=math-block><span class=katex><math display=block xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>μ</mi><mo>=</mo><mrow><mo fence=true>[</mo><mn>1</mn><mo>+</mo><mfrac><mrow><msub><mi>e</mi><mi>c</mi></msub><mo>−</mo><msub><mi>e</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><msub><mi>e</mi><mi>c</mi></msub></mfrac><mo fence=true>]</mo></mrow></mrow><annotation encoding=application/x-tex> \mu = \left [1 + \frac{e_c - e_{best}}{e_c} \right] </annotation></semantics></math></span></div><p>and T_k is the temperature at step <code>k</code> using any one of the previous methods. Also, <code>e_c</code> is the energy at the current step, and <code>e_best</code> is the best energy state achieved thus far.</p><p>All these approaches are useful, but of particular interest are the multiplicative and additive cooling schedules. Cooling schedules in general are fairly simple, but these are the simplest. Throughout this entire tutorial, a linear additive cooling schedule has been used and from my experience, will always deliver decent results.</p><p>As you might expect, the cooling schedule names are fairly indicative of how they behave. Upon visualization, it’s interesting to see how these cooling schedules differ from each other. We can see that the linear approach favors both exploration and exploitation equally where as the exponential and logarithmic schemes force the transition into exploit mode much sooner.</p><img alt="simulated annealing cooling schedules" src=cooling_schedules.svg style=max-width:350px><p>All of these cooling schedules are available in the current implementation. As an example, if we wanted the linear additive cooling schedule, we just need to specify it as follows:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>sa<span style=color:#555>.</span>minimize(cost_func, x0, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>'linear'</span>)
</span></span></code></pre></div><p>By not specifying a value for <code>alpha</code>, the cooling schedule will default to the additive scheme. In the event that the multiplicative version of linear cooling is required, just specify a value for alpha.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-py data-lang=py><span style=display:flex><span>sa<span style=color:#555>.</span>minimize(cost_func, x0, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>'linear'</span>, alpha<span style=color:#555>=</span><span style=color:#f60>0.8</span>)
</span></span></code></pre></div><h2 id=tips-on-using-sa-effectively>Tips on Using SA Effectively</h2><p>This last section here is comprised of what I’ve learned to be most helpful when using simulated annealing. Given that SA only requires a few parameters, it’s important that we do our best to set them accordingly. Doing so will increase the likelihood of obtaining the optimal solution.</p><p><b>cooling schedule</b>: If we know our cost function is smooth and unimodal or nearly unimodal, then don’t waste excess time exploring the search space. Instead, force the transition to gradient decent sooner rather than later with a logarithmic or exponential cooling schedule. On the other hand, if the cost function is highly multi-modal and an investment in exploration is warranted, go with the linear or quadratic cooling schedules. If you’re unsure, keep it simple and go with the linear schedule.</p><p><b>initial temperature</b>: Depending on how expensive the cost function is in terms of compute requirements, one of the easiest ways to determine <code>t_max</code> is by running SA over a range of <code>t_max</code> values with a constant temperature while checking the acceptance rate (the rate at which neighbor candidates are accepted). By holding the temperature constant, we can easily determine which range of <code>t_max</code> values will give us our initial desired acceptance rate. Usually, an initial acceptance rate of 0.8 or greater is used.</p><p>One way to maintain a constant temperature during optimization is by using the linear cooling schedule with an alpha set to zero as follows:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-python data-lang=python><span style=display:flex><span>sa<span style=color:#555>.</span>minimize(cost_func, x0, t_max<span style=color:#555>=</span><span style=color:#f60>10</span>, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>'linear'</span>, alpha<span style=color:#555>=</span><span style=color:#f60>0</span>)
</span></span></code></pre></div><p>After completion, the acceptance rate can then be checked via:</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-python data-lang=python><span style=display:flex><span>sa<span style=color:#555>.</span>acceptance_rate
</span></span></code></pre></div><p>which can be persisted in memory and plotted like so:</p><img alt="empirically determining initial temperature for simulated annealing" src=initial_temperature.svg><p>We can see that with any initial temperature greater than about two, we’ll likely be wasting our time. For a more rigorous approach to calculating t_max see: <i>Computing the Initial Temperature of Simulated Annealing</i>.<sup id=fnref:5><a class=footnote-ref href=#fn:5 role=doc-noteref>5</a></sup></p><p><b>max steps</b>: To state the obvious; more is better, …but only if you’re seeing improvements. One way to check if max_steps has been set correctly is by looking at how the solution converges.</p><div class=highlight><pre style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;background-color:#f0f3f3 tabindex=0><code class=language-python data-lang=python><span style=display:flex><span>step, temp, current_energy, best_energy <span style=color:#555>=</span> <span style=color:#366>zip</span>(<span style=color:#555>*</span>opt<span style=color:#555>.</span>hist)
</span></span></code></pre></div><p>If you plot these out and see that improvements become stagnate halfway through there’s a few possible routes you can take. If you’re confident in the cooling schedule choice and initial temperature, then max_iters can safely be reduced. If you’re not confident or you think you might be getting trapped in a local minima, better re-evaluate the initial temperature and cooling schedule.</p><h2 id=final-thoughts>Final Thoughts</h2><p>Simulated annealing can be a tricky algorithm to get right, but once it’s dialed in it’s actually pretty good. It’s one of those situations in which preparation is greatly rewarded. It’s probably overkill for most applications, however there are those rare situations which demand something stronger than the usual methods and simulated annealing will gladly deliver. Hopefully by shedding some light on the inner workings of this very simple but powerful scheme, you may find yourself (just like I have) using it a little more often.</p><p>Lastly, if you find anything that wasn’t completely clear please reach out because odds are other people feel the same way. I hope this tutorial was helpful, thanks for reading!</p><p>- Nathan</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Peter W. Merlin, <a href=/unlimited-horizons.pdf target=_blank><i>Unlimited Horizons: Design and Development of the U-2</i></a> (NASA Aeronautics Book Series, 2015) <a class=footnote-backref href=#fnref:1 role=doc-backlink>↩︎</a></p></li><li id=fn:2><p>Mark Drela, <a href=/xfoil_sv.pdf target=_blank><i>XFOIL: An Analysis and Design System for Low Reynolds Number Airfoils</i></a> (MIT Dept. of Aeronautics and Astronautics, Cambridge, Massachusetts) <a class=footnote-backref href=#fnref:2 role=doc-backlink>↩︎</a></p></li><li id=fn:3><p>Joseph Katz, Allen Plotkin, <a href=https://www.goodreads.com/book/show/1360255.Low_Speed_Aerodynamics target=_blank><i>Low-Speed Aerodynamics</i></a> (Cambridge University Press - 2001) <a class=footnote-backref href=#fnref:3 role=doc-backlink>↩︎</a></p></li><li id=fn:4><p>Yaghout Nourani and Bjarne Andresen, <a href=https://www.fys.ku.dk/~andresen/BAhome/ownpapers/permanents/annealSched.pdf target=_blank><i>A comparison of simulated annealing cooling strategies</i></a> (Journal of Physics A: Mathematical and General Volume 31, Number 41. October 16, 1998) <a class=footnote-backref href=#fnref:4 role=doc-backlink>↩︎</a></p></li><li id=fn:5><p>Walid Ben-Ameur, <a href=https://www.researchgate.net/publication/227061666_Computing_the_Initial_Temperature_of_Simulated_Annealing target=_blank><i>Computing the Initial Temperature of Simulated Annealing</i></a> (Computational Optimization and Applications 29(3):369-385 - December 2004) <a class=footnote-backref href=#fnref:5 role=doc-backlink>↩︎</a></p></li></ol></div></div></div></body></html>