<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=author content="Nathan Rooy"><meta name=copyright content="Nathan A. Rooy"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=language content="en"><link rel=icon type=image/png href=/favicon/favicon.png><title itemprop=name>Nathan Rooy</title><link rel=canonical href=https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/ itemprop=url><base href=https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/><meta itemprop=name content="Effective Simulated Annealing with Python | Nathan Rooy"><meta itemprop=description content="Effective Simulated Annealing with Python"><meta name=description content="Effective Simulated Annealing with Python"><meta name=application-name content="Effective Simulated Annealing with Python | Nathan Rooy"><meta name=keywords content="simulated annealing,python,global optimization,tutorial"><meta name=twitter:card content="nathanrooy.github.io"><meta name=twitter:url content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/"><meta name=twitter:title content="Effective Simulated Annealing with Python | Nathan Rooy"><meta name=twitter:description content="Effective Simulated Annealing with Python"><meta property="og:title" content="Effective Simulated Annealing with Python"><meta property="og:description" content="Effective Simulated Annealing with Python"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/"><meta property="og:site_name" content="nathanrooy.github.io"><meta itemprop=image content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/u2.png"><meta property="og:image" content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/u2.png"><meta name=twitter:image content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/u2.png"><meta name=twitter:image:src content="https://nathanrooy.github.io/posts/2020-05-14/simulated-annealing-with-python/u2.png"><link rel=alternate type=application/rss+xml href=https://nathanrooy.github.io/index.xml title="Nathan Rooy"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-88488688-1','auto'),ga('send','pageview')</script><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><div class="container wrapper post"><div class=header><div style=width:100%;display:inline class=site-title><h1 style=display:inline><a href=https://nathanrooy.github.io/>Nathan Rooy</a></h1><a style=float:right;padding-left:10px;display:inline target=_blank href=/index.xml title=rss><img style=margin:0;padding-top:1.2em src=/icons/rss_feather.svg width=20 height=20></a>
<a style=float:right;padding-left:10px;display:inline target=_blank href=https://github.com/nathanrooy/ title=github><img style=margin:0;padding-top:1.2em src=/icons/github_feather.svg width=20 height=20></a></div><hr style=width:100%;display:inline-block><nav class=nav><ul class=flat><li style=text-align:center;vertical-align:top><a href=/><img height=20px style=margin:0;padding:0 src=/icons/home_feather.svg></a></li><li style=text-align:center;vertical-align:top><a href=/about><img height=20px style=margin:0;padding:0 src=/icons/user_feather.svg></a></li><li><a href=/favorites><img height=20px style=margin:0;padding:0 src=/icons/trending-up_feather.svg></a></li></ul></nav></div><div class=post-header><h1 class=title>Effective Simulated Annealing with Python</h1><div class=meta>Posted: May 14, 2020</div></div><div class=markdown><h3 id=introduction>Introduction</h3><p>I use some form of optimization on a daily basis, whether it&rsquo;s for work or personal projects. Something else I do on a daily basis is avoid <a target=_blank href=https://en.wikipedia.org/wiki/Simulated_annealing>simulated annealing</a>. I&rsquo;ve always associated simulated annealing with inefficiency. Yes, it&rsquo;s a global optimizer, but at what cost? In most situations I&rsquo;ve been able to achieve optimal or near-optimal results in a substantially quicker time using various other methods (<a terget=_blank href=https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/>particle swarm</a>, <a target=_blank href=https://nathanrooy.github.io/posts/2017-08-27/simple-differential-evolution-with-python/>genetic/evolutionary</a>, etc&mldr;). So what&rsquo;s the deal?</p><p>Over the winter I decided to invest some time in actually understanding this method and forced myself into using it. I learned a lot and actually use it from time to time now. I decided to document my learnings in the form of this tutorial to my future self and anyone else interested in simulated annealing.</p><h3 id=background>Background</h3><p>Simulated annealing is a probabilistic optimization scheme which guarantees convergence to the global minimum given sufficient run time. It&rsquo;s loosely based on the idea of a <a target=_blank href=https://en.wikipedia.org/wiki/Annealing_(metallurgy)>metallurgical annealing</a> in which a metal is heated beyond its critical temperature and cooled according to a specific schedule until it reaches its minimum energy state. This controlled cooling regiment results in unique material properties useful for specific applications.</p><p>At it&rsquo;s core, simulated annealing is based on equation [1] which represents the probability of jumping to the next energy level. Within the context of simulated annealing, <i>energy level</i> is simply the current value of whatever function that&rsquo;s being optimized.</p><p>$$ P(e_c, e_n, T) = e^{-\Delta E/T} \tag{1} $$</p><p style=margin:0><b>Nomenclature:</b></p><ul style=list-style:none;margin-top:0><li style=margin-bottom:0><span><p>$$ e_c $$</p><p style=margin-left:2rem>energy at current state</p></span></li><li style=margin-bottom:0><span><p>$$ e_n $$</p><p style=margin-left:2rem>energy at proposed neighbor site</p></span></li><li style=margin-bottom:0><span><p>$$ \Delta E $$</p><p style=margin-left:2rem>change in energy between current state and proposed neighbor state</p></span></li><li style=margin-bottom:0><span><p>$$ T $$</p><p style=padding-left:2rem>current system temperature</p></span></li></ul><p>The main loop for simulated annealing consists of generating <i>neighbor candidates</i> which are just potential solutions which are then randomly accepted based on an ever increasingly more stringent threshold (Equation [1]).</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>0)  # initialize
    t_current = t_start
    s_current = x0
    s_best = x0

1)  # main optimization loop
    while t_current &gt; t_min
        1.A) generate neighbor candidate -&gt; s_new
        1.B) if P(E(s_current), E(s_new), T) &gt;= random(0,1)
            s_current = s_new
        1.C) if E(s_new) &lt; E(s_best)
            s_best = s_new
        1.D) update t_current
      
2)  # end
    output results
</code></pre></div><p>Although these equations appear simple, there&rsquo;s actually a few interesting things going on. To point out the obvious, ΔE is positive for any transition resulting in a drop in energy (cost function improvement). Therefor the probability of accepting a lower energy state is 100%, while accepting a worse energy state is a non-zero value that depends on the size of the energy increase and the current system temperature. This also means that the ability to jump to a worse energy level is a very real possibility (which is actually a good thing).</p><p>When the annealing process first begins, the temperature is high and the acceptance criteria for a new neighbor candidate is relaxed. This means the peaks and valleys of the energy landscape are largely ignored resulting in a process not unlike a random walk. Bouncing aimlessly between high and low energy levels might seem counterproductive, however there is a method to this madness. It&rsquo;s this erratic behavior that drives exploration of the search space, thus enabling it to find the global minimum. As the temperature is slowly cooled the acceptance criteria begins to narrow and the likelihood of transitioning to a neighbor candidate with a larger energy difference drops. At this point, simulated annealing is acting in a way which resembles stochastic gradient decent. The focus is centered around improvements rather than exploration and will <i>generally</i> follow a path of constant decent but may still jump around. As the system approaches its minimum energy state, only the smallest deviations in energy are accepted. This behavior is analogous to gradient decent in that it&rsquo;s limited to just the local search space and driven entirely by solution improvement.</p><table><thead><tr><th>temperature</th><th>approx. method</th><th>mode</th></tr></thead><tbody><tr><td>high</td><td>random walk</td><td>global exploration</td></tr><tr><td>med</td><td>stochastic gradient decent</td><td>improvement focused</td></tr><tr><td>low</td><td>gradient decent</td><td>local search / exploit</td></tr></tbody></table><p>Balancing the transition phase between a global optimizer exploring the search space and a local optimizer exploiting only what&rsquo;s in front is critical to achieving good results with simulated annealing. Using an aggressive cooling schedule on a highly multi-modal energy landscape can result in a solution frozen into a local minima, unable to escape to a lower energy level further away. Using a slower cooling schedule, will reduce the chances of getting trapped at the expense of increased computational requirements.</p><p>The simplicity of simulated annealing becomes further evident from its implementation in code below:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># begin optimizing</span>
self<span style=color:#555>.</span>step, self<span style=color:#555>.</span>accept <span style=color:#555>=</span> <span style=color:#f60>1</span>, <span style=color:#f60>0</span>
<span style=color:#069;font-weight:700>while</span> self<span style=color:#555>.</span>step <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>step_max <span style=color:#000;font-weight:700>and</span> self<span style=color:#555>.</span>t <span style=color:#555>&gt;=</span> self<span style=color:#555>.</span>t_min:

    <span style=color:#09f;font-style:italic># get neighbor</span>
    proposed_neighbor <span style=color:#555>=</span> self<span style=color:#555>.</span>get_neighbor()

    <span style=color:#09f;font-style:italic># check energy level of neighbor</span>
    E_n <span style=color:#555>=</span> self<span style=color:#555>.</span>cost_func(proposed_neighbor)
    dE <span style=color:#555>=</span> E_n <span style=color:#555>-</span> self<span style=color:#555>.</span>current_energy
    
    <span style=color:#09f;font-style:italic># determine if we should accept the current neighbor</span>
    <span style=color:#069;font-weight:700>if</span> random() <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>safe_exp(<span style=color:#555>-</span>dE <span style=color:#555>/</span> self<span style=color:#555>.</span>t):
        self<span style=color:#555>.</span>current_energy <span style=color:#555>=</span> E_n
        self<span style=color:#555>.</span>current_state <span style=color:#555>=</span> proposed_neighbor[:]
        self<span style=color:#555>.</span>accept <span style=color:#555>+=</span> <span style=color:#f60>1</span>
        
    <span style=color:#09f;font-style:italic># check if the current neighbor is best solution so far</span>
    <span style=color:#069;font-weight:700>if</span> E_n <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>best_energy:
        self<span style=color:#555>.</span>best_energy <span style=color:#555>=</span> E_n
        self<span style=color:#555>.</span>best_state <span style=color:#555>=</span> proposed_neighbor[:]
    
    <span style=color:#09f;font-style:italic># update some stuff</span>
    self<span style=color:#555>.</span>t <span style=color:#555>=</span> self<span style=color:#555>.</span>update_t(self<span style=color:#555>.</span>step)
    self<span style=color:#555>.</span>step <span style=color:#555>+=</span> <span style=color:#f60>1</span>
</code></pre></div><p>Throughout this tutorial, the code examples shown represent the bulk of the important stuff. I did however omit some methods, and non-critical code in the interest of readability. The full code can be viewed [<a target=_blank href=https://github.com/nathanrooy/simulated-annealing/blob/master/simulated_annealing/sa.py>here</a>] or easily installed via the following:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>pip install git<span style=color:#555>+</span>https:<span style=color:#555>//</span>github<span style=color:#555>.</span>com<span style=color:#555>/</span>nathanrooy<span style=color:#555>/</span>simulated<span style=color:#555>-</span>annealing
</code></pre></div><p>Additionally, the example cases in the form of <a target=_blank href=https://jupyter.org/>Jupyter notebooks</a> can be found [<a target=_blank href=https://github.com/nathanrooy/simulated-annealing/tree/master/examples>here</a>]</p><h3 id=implementation---combinatorial>Implementation - Combinatorial</h3><p>What better way to start experimenting with simulated annealing than with the combinatorial classic: the <a target=_blank href=https://en.wikipedia.org/wiki/Travelling_salesman_problem>traveling salesman problem</a> (TSP). After all, SA was literally created to solve this problem.</p><p>The first thing we need to sort out is how we&rsquo;ll generate neighbor candidates. Luckily for combinatorial problems such as TSP, this is super easy. Given the <code>current_state</code> at iteration i, which is nothing more than a list of values representing nodes in the salesman&rsquo;s path, we&rsquo;re going to randomly swap two of them. Since this will be contained within the main <code>minimize</code> class, this becomes a simple method we&rsquo;ll call <code>move_combinatorial</code> and can be seen below.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>move_combinatorial</span>(self):
    <span style=color:#c30>&#39;&#39;&#39;
</span><span style=color:#c30>    Swaps two random nodes along a path
</span><span style=color:#c30>    &#39;&#39;&#39;</span>
    p0 <span style=color:#555>=</span> randint(<span style=color:#f60>0</span>, <span style=color:#366>len</span>(self<span style=color:#555>.</span>current_state)<span style=color:#555>-</span><span style=color:#f60>1</span>)
    p1 <span style=color:#555>=</span> randint(<span style=color:#f60>0</span>, <span style=color:#366>len</span>(self<span style=color:#555>.</span>current_state)<span style=color:#555>-</span><span style=color:#f60>1</span>)
    
    neighbor <span style=color:#555>=</span> self<span style=color:#555>.</span>current_state[:]
    neighbor[p0], neighbor[p1] <span style=color:#555>=</span> neighbor[p1], neighbor[p0]

    <span style=color:#069;font-weight:700>return</span> neighbor
</code></pre></div><p>Now that we have a way of generating neighbor candidates, we need to code out the actual TSP cost function. I went ahead and implemented the simplest version which utilizes a <a target=_blank href=https://en.wikipedia.org/wiki/Euclidean_distance>Euclidean distance</a> metric <code>calc_euclidean</code>. This could very easily be swapped out for something else such as <a target=_blank href=https://nathanrooy.github.io/posts/2016-09-07/haversine-with-python/>Haversine</a> or <a target=_blank href=https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/>Vincenty</a> (both available <a target=_blank href=https://github.com/nathanrooy/spatial-analysis>here</a>) if the nodes were instead specified as values of latitude and longitude.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>calc_euclidean</span>(p1, p2):    
    <span style=color:#069;font-weight:700>return</span> ((p1[<span style=color:#f60>0</span>] <span style=color:#555>-</span> p2[<span style=color:#f60>0</span>])<span style=color:#555>**</span><span style=color:#f60>2</span> <span style=color:#555>+</span> (p1[<span style=color:#f60>1</span>] <span style=color:#555>-</span> p2[<span style=color:#f60>1</span>])<span style=color:#555>**</span><span style=color:#f60>2</span>)<span style=color:#555>**</span><span style=color:#f60>0.5</span>
</code></pre></div><p>The main tsp class is as simple as it sounds:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>tsp</span>():
    <span style=color:#069;font-weight:700>def</span> __init__(self, dist_func, close_loop<span style=color:#555>=</span>True):
        self<span style=color:#555>.</span>dist_func <span style=color:#555>=</span> dist_func
        self<span style=color:#555>.</span>close_loop <span style=color:#555>=</span> close_loop
    
    <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>dist</span>(self, xy):
        <span style=color:#09f;font-style:italic># sequentially calculate distance between all tsp nodes</span>
        dist <span style=color:#555>=</span> <span style=color:#f60>0</span>
        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(xy)<span style=color:#555>-</span><span style=color:#f60>1</span>): 
            dist <span style=color:#555>+=</span> self<span style=color:#555>.</span>dist_func(xy[i<span style=color:#555>+</span><span style=color:#f60>1</span>], xy[i])

        <span style=color:#09f;font-style:italic># close the tsp loop by calculating the distance </span>
        <span style=color:#09f;font-style:italic># between the first and last points</span>
        <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>close_loop:
            dist <span style=color:#555>+=</span> self<span style=color:#555>.</span>dist_func(xy[<span style=color:#f60>0</span>], xy[<span style=color:#555>-</span><span style=color:#f60>1</span>])
        
        <span style=color:#069;font-weight:700>return</span> dist
</code></pre></div><p>The tsp cost function can then be initialized in the following way:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>tsp_dist <span style=color:#555>=</span> tsp(dist_func<span style=color:#555>=</span>calc_euclidean, close_loop<span style=color:#555>=</span>True)<span style=color:#555>.</span>dist
</code></pre></div><p>In the interest of keeping it simple while starting out, let&rsquo;s create a tsp path in the shape of a circle. Since we know the optimal solution will follow the perimeter, it will be easy to validate.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n_pts <span style=color:#555>=</span> <span style=color:#f60>10</span>
dr <span style=color:#555>=</span> (<span style=color:#f60>2</span> <span style=color:#555>*</span> pi) <span style=color:#555>/</span> n_pts

x0 <span style=color:#555>=</span> []
<span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,n_pts):
    radians <span style=color:#555>=</span> dr <span style=color:#555>*</span> i  
    x0<span style=color:#555>.</span>append([cos(radians), sin(radians)])
shuffle(x0)
</code></pre></div><p>With 10 points, the optimal energy (path length in this case) is ~6.1803 (just under 2π) but jumps to 15.3540 because of the random shuffle. Now, everything is in place and we can begin optimizing.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
    tsp_dist,
    x0,
    opt_mode<span style=color:#555>=</span><span style=color:#c30>&#39;combinatorial&#39;</span>,
    step_max<span style=color:#555>=</span><span style=color:#f60>750</span>,
    t_max<span style=color:#555>=</span><span style=color:#f60>4</span>,
    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>) 
</code></pre></div><p>Once finished, we can view the results by calling the <code>results()</code> method:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>opt<span style=color:#555>.</span>results()
</code></pre></div><p>Which will yield the following (usually):</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#555>+------------------------</span> RESULTS <span style=color:#555>-------------------------+</span>

cooling sched<span style=color:#555>.</span>: linear
      opt<span style=color:#555>.</span>mode: combinatorial

  initial temp: <span style=color:#f60>4</span>
    final temp: <span style=color:#f60>0.000000</span>
     <span style=color:#366>max</span> steps: <span style=color:#f60>750</span>
    final step: <span style=color:#f60>750</span>

  final energy: <span style=color:#f60>6.180340</span>

<span style=color:#555>+--------------------------</span> END <span style=color:#555>---------------------------+</span>
</code></pre></div><p>We can access the optimal solution via:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>opt<span style=color:#555>.</span>best_state
</code></pre></div><p>And then plot it to further validate that we have indeed achieved the global minimum.<figure><img src=tsp_circle_compare.png alt="circular traveling salesman problem"><figcaption><p>circular traveling salesman problem</p></figcaption></figure></p><p>In order to get a better understanding of how simulated annealing converges onto the solution for this example, I went ahead and ran it 1000 times and consolidated the results. The first plot below shows the current state of the optimizer. We can see that it really bounces around while the temperature is hot and the acceptance criteria is relaxed. We can also see that as the temperature starts to cool, it begins to focus on improvements rather than exploration.</p><figure><img src=tsp_circle_current_state.png alt="circular traveling salesman problem"><figcaption><p>circular traveling salesman problem</p></figcaption></figure><p>The last plot below, shows the best solution achieved throughout the optimization process. We can see that early on, simulated annealing is able to quickly capture the low hanging fruit during the exploration phase. After the quick gains, progress slows while it continues to search the energy landscape. It&rsquo;s not until the system temperature has cooled enough to force the transition from explore to exploit that meaningful improvements are achieved. It&rsquo;s this final regime in which local optimization becomes the priority and the pace of improvement accelerates right before reaching the final energy state.</p><figure><img src=tsp_circle_best_state.png alt="circular traveling salesman problem"><figcaption><p>circular traveling salesman problem</p></figcaption></figure><p>Okay I can&rsquo;t resist, lets swap out that distance function for something a little more fun/useful. Let&rsquo;s say we want to bike to every one of our favorite breweries in Cincinnati in the shortest distance possible (this is what initially piqued my interest in simulated annealing 🚴‍♂️🍺). In this situation, since we&rsquo;re limited to streets and bike paths we&rsquo;ll need to use network distance. However, since network distance relies on <a target=_blank href=https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>Dijkstra&rsquo;s algorithm</a> to find the shortest path between two nodes in a graph, it requires more compute power than the simpler Euclidean distance. We could keep it simple by coding out Dijkstra&rsquo;s algorithm and pairing that with the <a target=_blank href=https://en.wikipedia.org/wiki/OpenStreetMap>OpenStreetMap</a> network graph but we&rsquo;d be stuck calling the function a bunch of times for the same set of points. This is both lazy and inefficient. Instead, let&rsquo;s enumerate all origin-destination pairs and pre-compute the distances. We can then save the results in the form of a distance matrix which will act as a sort of lookup table allowing for super quick function calls. This results in a new distance function as seen below:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>calc_dict</span>(p1, p2, dist_dict<span style=color:#555>=</span>dist_dict):   
    <span style=color:#069;font-weight:700>return</span> dist_dict[p1,p2]
</code></pre></div><p>Which we can then use to initialize the updated tsp cost function:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>tsp_bike <span style=color:#555>=</span> tsp(dist_func<span style=color:#555>=</span>calc_dict, close_loop<span style=color:#555>=</span>True)<span style=color:#555>.</span>dist
</code></pre></div><p>Just as before, we&rsquo;ll call the <code>minimize</code> method from our simulated annealing class to begin the optimization.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
    tsp_bike,
    x0,
    opt_mode<span style=color:#555>=</span><span style=color:#c30>&#39;combinatorial&#39;</span>,
    step_max<span style=color:#555>=</span><span style=color:#f60>1000</span>, 
    t_max<span style=color:#555>=</span><span style=color:#f60>50</span>, 
    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>) 
</code></pre></div><p>Since the breweries are listed in an arbitrary order, the initial energy of the system is roughly 84481.27 which represents the total circuit length in meters (52.49 miles). Below is the initial state (red dots indicate brewery locations while the red line is the travel path):</p><figure><img src=tsp_cincy_initial.png alt="traveling salesman problem - Cincinnati breweries - initial"><figcaption><p>traveling salesman problem - Cincinnati breweries - initial</p></figcaption></figure><p>After optimization, the final state has an energy of roughly 51104.00 (31.75 miles) and can be seen below. I ran this example several times with varying levels of <code>t_max</code>, <code>t_min</code> and <code>max_iters</code> and they all converged to the same solution the majority of the time indicating that the energy landscape for this case is multi-modal but fairly smooth.</p><figure><img src=tsp_cincy_final.png alt="traveling salesman problem - Cincinnati breweries - final"><figcaption><p>traveling salesman problem - Cincinnati breweries - final</p></figcaption></figure><h3 id=implementation---continuous>Implementation - Continuous</h3><p>Now for the fun stuff; continuous real valued problems! Let&rsquo;s say you&rsquo;re an aerospace engineer working within Lockheed Skunk Works and aerospace legend <a target=_blank href=https://en.wikipedia.org/wiki/Kelly_Johnson_(engineer)>Kelly Johnson</a> stops by your desk and requests an airfoil for a new <a target=_blank href=https://en.wikipedia.org/wiki/Lockheed_U-2>high altitude reconnaissance aircraft</a> code named <i>Dragon Lady</i>.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> You&rsquo;ve got access to the best compute resources the 1950&rsquo;s has to offer and one day. Time is ticking.</p><figure><img src=u2.png alt="Dragon Lady aka the Lockheed U2"><figcaption><p>Dragon Lady aka the Lockheed U2</p></figcaption></figure><p>Ignoring the vast majority of constraints that are usually at play in a situation such as this, we&rsquo;re going to instead focus on a single objective: maximizing the ratio of lift to drag. For this, we&rsquo;ll start with the NACA 0012. This is a symmetric airfoil which means it has no <a target=_blank href=https://en.wikipedia.org/wiki/Camber_(aerodynamics)>camber</a> and subsequently generates no lift when the <a target=_blank href=https://en.wikipedia.org/wiki/Angle_of_attack>angle of attack</a> (<b>α</b>) is at zero degrees. This will provide a neutral starting point for this exercise.</p><p>The symmetric <a target=_blank href=https://en.wikipedia.org/wiki/NACA_airfoil>NACA 4-digit airfoils</a> are described using a simple formula which is based on the ratio of maximum thickness to <a target=_blank href=https://en.wikipedia.org/wiki/Chord_(aeronautics)>chord length</a>. This is great because it&rsquo;s simple and easy to implement, but terrible for optimization. How are we going to meaningfully change the shape of the airfoil if we only have this single ratio? Sure, we could use a more advanced NACA formulation but in the end, we&rsquo;re still going to limit ourselves. Instead, let&rsquo;s parameterize our airfoil using <a target=_blank href=https://en.wikipedia.org/wiki/B%C3%A9zier_curve>Bézier curves</a>. Because this is a tutorial on simulated annealing and not aerodynamic shape optimization, I&rsquo;ll spare all the juicy details for another day.</p><p>Long story short, the airfoil has been converted from a series of points into a parametric curve through the use of a composite quadratic Bézier curve (more on that <a target=_blank href=https://nathanrooy.github.io/posts/2016-09-14/airfoil-manipulation-via-bezier-curves-with-python/>here</a>). What this means, is that we can now morph the shape of this airfoil using a series of control points to generate an infinite number of different variations. Perfect for optimization.</p><figure><img src=bezier_naca0012.png alt="parametric naca 0012 airfoil"><figcaption><p>parametric naca 0012 airfoil</p></figcaption></figure><p>As seen from above, the airfoil has been parameterized with 10 control points, however the two at the trailing edge are fixed and the two leading edge control points can only move along the y-axis. The rest can move freely in both the x, and y directions. What this means is that we have a system with 13 degrees of freedom which is plenty enough for this task. Adding more control points would enable a higher level of fidelity but at the expense of a larger search space making optimization a more difficult.</p><p>Now that we have a parameterized airfoil we need to two more things: a way of generating neighbor candidates and a cost function. The neighbor generation for this example will remain simple, let&rsquo;s just randomly perturb each control point by a small random amount. In code, this looks like this:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>move_continuous</span>(self):
    <span style=color:#09f;font-style:italic># perturb current state by a random amount limited by the damping factor</span>
    neighbor <span style=color:#555>=</span> []
    <span style=color:#069;font-weight:700>for</span> item <span style=color:#000;font-weight:700>in</span> self<span style=color:#555>.</span>current_state:
        neighbor<span style=color:#555>.</span>append(item <span style=color:#555>+</span> ((random() <span style=color:#555>-</span> <span style=color:#f60>0.5</span>) <span style=color:#555>*</span> self<span style=color:#555>.</span>damping))
        
    <span style=color:#09f;font-style:italic># clip to upper and lower bounds</span>
    <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>bounds:            
        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(neighbor)):
            x_min, x_max <span style=color:#555>=</span> self<span style=color:#555>.</span>bounds[i]
            neighbor[i] <span style=color:#555>=</span> <span style=color:#366>min</span>(<span style=color:#366>max</span>(neighbor[i], x_min), x_max)  
                
    <span style=color:#069;font-weight:700>return</span> neighbor
</code></pre></div><p>Note, that I added a simple check that forces the new neighbor candidate to remain within some bounds as optionally specified by the user. Lastly, the cost function consists of nothing more than creating the new airfoil, calculating the aerodynamic forces, and returning the results. Aerodynamic forces will be calculated using <a target=_blank href=https://web.mit.edu/drela/Public/web/xfoil/>XFOIL</a> which is based on a linear-strength vortex panel method.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><sup>,</sup><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> Given the time period and compute limitations, panel methods would have been the likely approach taken rather than a <a target=_blank href=https://en.wikipedia.org/wiki/Computational_fluid_dynamics>CFD</a> based approach.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>cost_function</span>(x, x_coords<span style=color:#555>=</span>x_cos):
    airfoil_file <span style=color:#555>=</span> <span style=color:#c30>&#39;airfoil.txt&#39;</span>
    
    <span style=color:#069;font-weight:700>try</span>:
        <span style=color:#09f;font-style:italic># munge x-vector into bezier format</span>
        control_pts <span style=color:#555>=</span> munge_ctlpts(x)

        <span style=color:#09f;font-style:italic># generate new airfoil</span>
        curve <span style=color:#555>=</span> bezier_airfoil(x_coords, control_pts)

        <span style=color:#09f;font-style:italic># output airfoil to csv</span>
        <span style=color:#069;font-weight:700>with</span> <span style=color:#366>open</span>(airfoil_file,<span style=color:#c30>&#39;w&#39;</span>) <span style=color:#069;font-weight:700>as</span> out_file:
            out_file<span style=color:#555>.</span>write(<span style=color:#c30>&#39;x,y</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#39;</span>)
            <span style=color:#069;font-weight:700>for</span> item <span style=color:#000;font-weight:700>in</span> curve:
                out_file<span style=color:#555>.</span>write(f<span style=color:#c30>&#39;{item[0]},{item[1]}</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#39;</span>)

        <span style=color:#09f;font-style:italic># run xfoil and collect results</span>
        results_dict <span style=color:#555>=</span> run_xfoil()
        
        <span style=color:#09f;font-style:italic># determine cost</span>
        cost <span style=color:#555>=</span> results_dict[<span style=color:#c30>&#39;cl&#39;</span>] <span style=color:#555>/</span> results_dict[<span style=color:#c30>&#39;cd&#39;</span>]
        <span style=color:#069;font-weight:700>if</span> results_dict[<span style=color:#c30>&#39;cl&#39;</span>] <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>: cost <span style=color:#555>=</span> <span style=color:#f60>0.01</span>
        
    <span style=color:#069;font-weight:700>except</span>:
        cost <span style=color:#555>=</span> <span style=color:#f60>0.01</span>
    
    <span style=color:#09f;font-style:italic># remove temp airfoil file</span>
    os<span style=color:#555>.</span>system(f<span style=color:#c30>&#39;rm -rf {airfoil_file}&#39;</span>)
    
    <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>1000.0</span> <span style=color:#555>/</span> cost
</code></pre></div><p>Now, everything is in place and we can begin optimizing (reference the jupyter notebook [<a target=_blank href=https://github.com/nathanrooy/simulated-annealing/blob/master/examples/airfoil/airfoil.ipynb>here</a>] for all the details).</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>opt <span style=color:#555>=</span> sa<span style=color:#555>.</span>minimize(
    cost_function,
    x0,
    opt_mode<span style=color:#555>=</span><span style=color:#c30>&#39;continuous&#39;</span>,
    step_max<span style=color:#555>=</span><span style=color:#f60>125</span>,
    t_max<span style=color:#555>=</span><span style=color:#f60>2</span>,
    t_min<span style=color:#555>=</span><span style=color:#f60>0</span>,
    damping<span style=color:#555>=</span><span style=color:#f60>0.01</span>)
</code></pre></div><p>Because the initial reverse-fitting yielded an airfoil that wasn&rsquo;t perfectly symmetrical, the initial L/D was slightly less than 0.5, while the optimized airfoil achieved an L/D of just over 100. While running this example, it&rsquo;s fairly common to get an airfoil with an L/D nearing 200 however these tend to be structurally unfeasible and suffer from highly unfavorable stability characteristics. So what you see below is actually not a global optimum but a slightly more realistic local optimum.</p><figure><img src=final_airfoil_compare.png alt="optimized airfoil"><figcaption><p>optimized airfoil</p></figcaption></figure><p>Given that XFOIL is able to calculate all useful aerodynamic forces, it would be trivial to incorporate additional constraints such as stability or lift across a range of <a target=_blank href=https://en.wikipedia.org/wiki/Reynolds_number>Reynolds numbers</a>.</p><h3 id=cooling-schedules>Cooling Schedules</h3><p>The concept of a cooling schedule is a big part of simulated annealing and until now I&rsquo;ve purposely left out how temperature reduction actually occurs. They come in a number of different flavors and the choice of which cooling schedule to use is considered an important decision.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> There exists a whole body of research on cooling schedules each with their own advantages and disadvantages. Some such as <i>multiplicative monotonic cooling schedules</i> rely on nothing more than the starting temperature (T_max), the current step (k), and a manually set constant alpha.</p><p>linear multiplicative</p><p>$$ T(k) = T_{max} - \alpha k \tag{3} $$
natural log
exponential multiplicative</p><p>$$ T(k) = T_{max} \alpha^{k} \tag{4} $$</p><p>logarithmic multiplicative</p><p>$$ T(k) = \frac{T_{max}}{1 + \alpha log(k+1)} \tag{5} $$</p><p>quadratic multiplicative</p><p>$$ T(k) = \frac{T_{max}}{1 + \alpha k^2} \tag{6} $$</p><p>On the other hand, <i>additive monotonic cooling schedules</i> depend on two additional parameters: the total number of steps <code>n</code> and the final temperature (t_min).</p><p>linear additive:</p><p>$$ T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{n - k}{n} \right) \tag{7} $$</p><p>exponential additive:</p><p>$$ T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{1}{1+e^{\frac{2 \ln (T_{max}-T_{min})}{n} \left(k-\frac{1}{2}n \right)}} \right) \tag{8} $$</p><p>quadratic additive:</p><p>$$ T(k) = T_{min} + (T_{max} - T_{min}) \left( \frac{n - k}{n} \right)^2 \tag{9} $$</p><p>Lastly, we have the <i>non-monotonic adaptive cooling schedules</i> which involve all previously mentioned parameters as well as an adaptive factor based on the difference between the current state and the best state achieved thus far.</p><p>$$ T(k) = \mu T_k $$</p><p>Where:</p><p>$$ \mu = \left [1 + \frac{e_c - e_{best}}{e_c} \right] $$</p><p>and T_k is the temperature at step <code>k</code> using any one of the previous methods. Also, <code>e_c</code> is the energy at the current step, and <code>e_best</code> is the best energy state achieved thus far.</p><p>All these approaches are useful, but of particular interest are the multiplicative and additive cooling schedules. Cooling schedules in general are fairly simple, but these are the simplest. Throughout this entire tutorial, a linear additive cooling schedule has been used and from my experience, will always deliver decent results.</p><p>As you might expect, the cooling schedule names are fairly indicative of how they behave. Upon visualization, it&rsquo;s interesting to see how these cooling schedules differ from each other. We can see that the linear approach favors both exploration and exploitation equally where as the exponential and logarithmic schemes force the transition into exploit mode much sooner.</p><figure><img src=cooling_schedules.png alt="simulated annealing cooling schedules"><figcaption><p>simulated annealing cooling schedules</p></figcaption></figure><p>All of these cooling schedules are available in the current implementation. As an example, if we wanted the linear additive cooling schedule, we just need to specify it as follows:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sa<span style=color:#555>.</span>minimize(cost_func, x0, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>&#39;linear&#39;</span>)
</code></pre></div><p>By not specifying a value for <code>alpha</code>, the cooling schedule will default to the additive scheme. In the event that the multiplicative version of linear cooling is required, just specify a value for alpha.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sa<span style=color:#555>.</span>minimize(cost_func, x0, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>&#39;linear&#39;</span>, alpha<span style=color:#555>=</span><span style=color:#f60>0.8</span>)
</code></pre></div><h3 id=tips-on-using-sa-effectively>Tips on Using SA Effectively</h3><p>This last section here is comprised of what I&rsquo;ve learned to be most helpful when using simulated annealing. Given that SA only requires a few parameters, it&rsquo;s important that we do our best to set them accordingly. Doing so will increase the likelihood of obtaining the optimal solution.</p><p><b>cooling schedule</b>: If we know our cost function is smooth and unimodal or nearly unimodal, then don&rsquo;t waste excess time exploring the search space. Instead, force the transition to gradient decent sooner rather than later with a logarithmic or exponential cooling schedule. On the other hand, if the cost function is highly multi-modal and an investment in exploration is warranted, go with the linear or quadratic cooling schedules. If you&rsquo;re unsure, keep it simple and go with the linear schedule.</p><p><b>initial temperature</b>: Depending on how expensive the cost function is in terms of compute requirements, one of the easiest ways to determine <code>t_max</code> is by running SA over a range of <code>t_max</code> values with a constant temperature while checking the acceptance rate (the rate at which neighbor candidates are accepted). By holding the temperature constant, we can easily determine which range of <code>t_max</code> values will give us our initial desired acceptance rate. Usually, an initial acceptance rate of 0.8 or greater is used.</p><p>One way to maintain a constant temperature during optimization is by using the linear cooling schedule with an alpha set to zero as follows:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sa<span style=color:#555>.</span>minimize(cost_func, x0, t_max<span style=color:#555>=</span><span style=color:#f60>10</span>, cooling_schedule<span style=color:#555>=</span><span style=color:#c30>&#39;linear&#39;</span>, alpha<span style=color:#555>=</span><span style=color:#f60>0</span>)
</code></pre></div><p>After completion, the acceptance rate can then be checked via:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sa<span style=color:#555>.</span>acceptance_rate
</code></pre></div><p>which can be persisted in memory and plotted like so:</p><figure><img src=t_max.png alt="empirically determining initial temperature"><figcaption><p>empirically determining initial temperature</p></figcaption></figure><p>We can see that with any initial temperature greater than about two, we&rsquo;ll likely be wasting our time. For a more rigorous approach to calculating t_max see: <i>Computing the Initial Temperature of Simulated Annealing</i>.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p><b>max steps</b>: To state the obvious; more is better, &mldr;but only if you&rsquo;re seeing improvements. One way to check if max_steps has been set correctly is by looking at how the solution converges.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>step, temp, current_energy, best_energy <span style=color:#555>=</span> <span style=color:#366>zip</span>(<span style=color:#555>*</span>opt<span style=color:#555>.</span>hist)
</code></pre></div><p>If you plot these out and see that improvements become stagnate halfway through there&rsquo;s a few possible routes you can take. If you&rsquo;re confident in the cooling schedule choice and initial temperature, then max_iters can safely be reduced. If you&rsquo;re not confident or you think you might be getting trapped in a local minima, better re-evaluate the initial temperature and cooling schedule.</p><h3 id=final-thoughts>Final Thoughts</h3><p>Simulated annealing can be a tricky algorithm to get right, but once it&rsquo;s dialed in it&rsquo;s actually pretty good. It&rsquo;s one of those situations in which preparation is greatly rewarded. It&rsquo;s probably overkill for most applications, however there are those rare situations which demand something stronger than the usual methods and simulated annealing will gladly deliver. Hopefully by shedding some light on the inner workings of this very simple but powerful scheme, you may find yourself (just like I have) using it a little more often.</p><p>Lastly, if you find anything that wasn&rsquo;t completely clear please reach out because odds are other people feel the same way. I hope this tutorial was helpful, thanks for reading!</p><p>- Nathan</p><h3 id=references>References</h3><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Peter W. Merlin, <a target=_blank href=/unlimited-horizons.pdf><i>Unlimited Horizons: Design and Development of the U-2</i></a> (NASA Aeronautics Book Series, 2015) <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Mark Drela, <a target=_blank href=/xfoil_sv.pdf><i>XFOIL: An Analysis and Design System for Low Reynolds Number Airfoils</i></a> (MIT Dept. of Aeronautics and Astronautics, Cambridge, Massachusetts) <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Joseph Katz, Allen Plotkin, <a target=_blank href=https://www.goodreads.com/book/show/1360255.Low_Speed_Aerodynamics><i>Low-Speed Aerodynamics</i></a> (Cambridge University Press - 2001) <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Yaghout Nourani and Bjarne Andresen, <a target=_blank href=https://www.fys.ku.dk/~andresen/BAhome/ownpapers/permanents/annealSched.pdf><i>A comparison of simulated annealing cooling strategies</i></a> (Journal of Physics A: Mathematical and General Volume 31, Number 41. October 16, 1998) <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Walid Ben-Ameur, <a target=_blank href=https://www.researchgate.net/publication/227061666_Computing_the_Initial_Temperature_of_Simulated_Annealing><i>Computing the Initial Temperature of Simulated Annealing</i></a> (Computational Optimization and Applications 29(3):369-385 - December 2004) <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><hr></div><div class=footer><center>&copy; <a href=/about>Nathan A. Rooy</a>.<br>Built with <a target=_blank href=https://gohugo.io/ rel=nofollow>Hugo</a>.
Powered by <a target=_blank href=http://www.github.com>GitHub</a></center></div></body></html>