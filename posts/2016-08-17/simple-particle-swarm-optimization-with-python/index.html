<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=author content="Nathan Rooy"><meta name=copyright content="Nathan A. Rooy"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=language content="en"><link rel=icon type=image/png href=/favicon/favicon.png><title itemprop=name>Nathan Rooy</title><link rel=canonical href=https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/ itemprop=url><base href=https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/><meta itemprop=name content="Particle Swarm Optimization from Scratch with Python | Nathan Rooy"><meta itemprop=description content="A tutorial that covers the basics of particle swarm optimization while implementing a simplified, barebones version with Python"><meta name=description content="A tutorial that covers the basics of particle swarm optimization while implementing a simplified, barebones version with Python"><meta name=application-name content="Particle Swarm Optimization from Scratch with Python | Nathan Rooy"><meta name=keywords content="particle swarm optimization,python,tutorial,evolutionary optimization,optimization"><meta name=twitter:card content="nathanrooy.github.io"><meta name=twitter:url content="https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/"><meta name=twitter:title content="Particle Swarm Optimization from Scratch with Python | Nathan Rooy"><meta name=twitter:description content="A tutorial that covers the basics of particle swarm optimization while implementing a simplified, barebones version with Python"><meta property="og:title" content="Particle Swarm Optimization from Scratch with Python"><meta property="og:description" content="A tutorial that covers the basics of particle swarm optimization while implementing a simplified, barebones version with Python"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/"><meta property="og:site_name" content="nathanrooy.github.io"><meta itemprop=image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta property="og:image" content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><meta name=twitter:image:src content="https://nathanrooy.github.io/about/DSC_3706-EDIT-BLOG-TINY.jpg"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-88488688-1','auto'),ga('send','pageview')</script><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://nathanrooy.github.io/css/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><div class="container wrapper post"><div class=header><div style=width:100% class=site-title><h1 style=display:inline><a href=https://nathanrooy.github.io/>Nathan Rooy</a></h1><a style=float:right;padding-left:10px;display:inline target=_blank href=/index.xml title=rss><img src=/icons/rss_feather.svg width=20 height=20></a>
<a style=float:right;padding-left:10px;display:inline target=_blank href=https://github.com/nathanrooy/ title=github><img src=/icons/github_feather.svg width=20 height=20></a></div><hr><nav class=nav><ul class=flat><li style=text-align:center;vertical-align:top><a href=/><img height=20px style=margin:0;padding:0 src=/icons/home_feather.svg></a></li><li style=text-align:center;vertical-align:top><a href=/about><img height=20px style=margin:0;padding:0 src=/icons/user_feather.svg></a></li><li><a href=/favorites><img height=20px style=margin:0;padding:0 src=/icons/trending-up_feather.svg></a></li></ul></nav></div><div class=post-header><h1 class=title>Particle Swarm Optimization from Scratch with Python</h1><div class=meta>Posted at &mdash; August 17, 2016</div></div><div class=markdown><p>Particle swarm optimization (<a target=_blank href=https://en.wikipedia.org/wiki/Particle_swarm_optimization>PSO</a>) is one of those rare tools that’s comically simple to code and implement while producing bizarrely good results. Developed in 1995 by Eberhart and Kennedy, PSO is a biologically inspired optimization routine designed to mimic birds flocking or fish schooling. I’ll occasionally use PSO for <a target=_blank href=https://en.wikipedia.org/wiki/Computational_fluid_dynamics>CFD</a> based aerodynamic shape optimization, but more often than not, it’s for a machine learning project. PSO is not guaranteed to find the global minimum, but it does a solid job in challenging, high dimensional, non-convex, non-continuous environments. In this short introductory tutorial, I’ll demonstrate PSO in its absolute simplest form. At a later date, I’ll create another PSO tutorial featuring a more advanced implementation.</p><p>Below, are the only two equations that make up a bare bones PSO algorithm. As a heads up, “k” references the current iteration, therefore “k+1″ implies the next iteration.</p><p>Particle position:</p><p><span class=math>\[ x_{k+1}^i = x_{k}^i + v_{k+1}^i \]</span></p><p>Particle velocity:</p><p><span class=math>\[ v_{k+1}^i = w_k v_k^i + c_1 r_1 \left(p_k^i - x_k^i\right) + c_2 r_2 \left(p_k^g - x_k^i\right) \]</span></p><p>Where:</p><p><center><table style=width:60%;line-height:2.5em;max-width:400px><col width=40%><col width=60%><thead><th><strong>Variable</strong></th><th><strong>Definition</strong></th></thead><tbody><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( x_k^i \)</span></td><td>particle position</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( v_k^i \)</span></td><td>particle position</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( p_k^i \)</span></td><td>best individual particle position</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( p_k^g \)</span></td><td>best swarm position</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( w_k \)</span></td><td>constant inertia weight</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( c_1, c_2 \)</span></td><td>cognitive and social parameters respectively</td></tr><tr><td><equation class=has-jax style=padding-left:30px><span class=math>\( r_1, r_2 \)</span></td><td>random numbers between 0 and 1</td></tr></tbody></table></center></p><p>From the particle velocity equation, two important groups emerge:<ol class=ul-style-b><li>social term: <span class=math>\( c_2 r_2 \left(p_k^g - x_k^i\right) \)</span></li><li>cognitive term: <span class=math>\( c_1 r_1 \left(p_k^i - x_k^i\right) \)</span></li></ol>Using these two simple equations, the basic flow structure of a PSO routine is as follows:</p><p>A) Initialize<ol class=ul-style-b><li>Set constants: <span class=math>\( k_{max}, w_k, c_1, c_2 \)</span></li><li>Randomly initialize particle positions.</li><li>Randomly initialize particle velocities.</li><li>Set k=1 (iteration counter).</li></ol></p><p>B) Optimize<ol class=ul-style-b><li>Evaluate cost function <span class=math>\( f_k^i \)</span> at each particle position <span class=math>\( x_k^i \)</span></li><li>If <span class=math>\( f_k^i \le f_{best}^i \)</span> then <span class=math>\( f_{best}^i = f_k^i \)</span> and <span class=math>\( p_k^i = x_k^i \)</span>.</li><li>If <span class=math>\( f_k^i \le f_{best}^g \)</span> then <span class=math>\( f_{best}^g = f_k^i \)</span> and <span class=math>\( p_k^g = x_k^i \)</span>.</li><li>If stopping condition is satisfied, go to C.</li><li>Update all particle velocities.</li><li>Update all particle positions.</li><li>Increment k.</li><li>Go to B(1).</li></ol></p><p>C) Terminate</p><p>That’s it! It’s really that simple. The main concept behind PSO, which is evident from the particle velocity equation above, is that there is a constant balance between three distinct forces pulling on each particle:</p><ol class=ul-style-b><li>The particles previous velocity (inertia)</li><li>Distance from the individual particles’ best known position (cognitive force)</li><li>Distance from the swarms best known position (social force)</li></ol><p>These three forces are then weighted by <span class=math>\( w_k \)</span>, <span class=math>\( c_1 \)</span>, <span class=math>\( c_2 \)</span> and randomly perturbed by <span class=math>\( r_1 \)</span> and <span class=math>\( r_2 \)</span>. Thus depending on the weighting, either the swarms best location <span class=math>\( p_k^g \)</span> or the particles own best position <span class=math>\( p_k^i \)</span> will pull harder on the particle and dictate the overall direction. That’s assuming the particles initial velocity (or inertia) won’t cause the particle to wonder around. Often times, if you notice that the convergence is taking longer it’s because the particle inertia is weighted to heavily and should be reduced to speed up convergence. Keep in mind, that particle inertia is a double-edged-sword. If you're dealing with a noisy, highly multimodal cost function, too little inertia could result in the particles getting trapped at a local minimum, unable to climb out.</p><p>In vector form, these three forces can be seen below (vector magnitude represents the weight value of that specific force):</p><p><img alt=pso-vector-1 title=pso-vector-1 src=pso-vector-1.png>
<center class=figcaption>Figure 1: a high energy particle that will keep exploring the search space</center></p><p>We can see in the above example that the weighting of the particles inertia and individual best overpower the swarms influence. In this scenario, the particle will continue exploring the search space rather than converge on the swarm. As another example below:</p><p><img alt=pso-vector-2 title=pso-vector-2 src=pso-vector-2.png>
<center class=figcaption>Figure 2: a lazy particle that follows the herd</center></p><p>This time, the weighting assigned to the swarms influence overpowers the individual forces of the particle forcing it towards the swarm. This will result in a faster convergence, at the expense of not fully exploring the search space and potentially finding a better solution.</p><p>The implementation of a simple PSO routine in python is fairly straightforward. We are going to utilize some object-oriented programming and create a swarm of particles using a particle class. These particles will be monitored by a main optimization class. Below is the entire code:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic>#------------------------------------------------------------------------------+</span>
<span style=color:#09f;font-style:italic>#</span>
<span style=color:#09f;font-style:italic>#   Nathan A. Rooy</span>
<span style=color:#09f;font-style:italic>#   Simple Particle Swarm Optimization (PSO) with Python</span>
<span style=color:#09f;font-style:italic>#   July, 2016</span>
<span style=color:#09f;font-style:italic>#</span>
<span style=color:#09f;font-style:italic>#------------------------------------------------------------------------------+</span>

<span style=color:#09f;font-style:italic>#--- IMPORT DEPENDENCIES ------------------------------------------------------+</span>

<span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>__future__</span> <span style=color:#069;font-weight:700>import</span> division
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>random</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>math</span>

<span style=color:#09f;font-style:italic>#--- COST FUNCTION ------------------------------------------------------------+</span>

<span style=color:#09f;font-style:italic># function we are attempting to optimize (minimize)</span>
<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>func1</span>(x):
    total<span style=color:#555>=</span><span style=color:#f60>0</span>
    <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(x)):
        total<span style=color:#555>+=</span>x[i]<span style=color:#555>**</span><span style=color:#f60>2</span>
    <span style=color:#069;font-weight:700>return</span> total

<span style=color:#09f;font-style:italic>#--- MAIN ---------------------------------------------------------------------+</span>

<span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>Particle</span>:
    <span style=color:#069;font-weight:700>def</span> __init__(self,x0):
        self<span style=color:#555>.</span>position_i<span style=color:#555>=</span>[]          <span style=color:#09f;font-style:italic># particle position</span>
        self<span style=color:#555>.</span>velocity_i<span style=color:#555>=</span>[]          <span style=color:#09f;font-style:italic># particle velocity</span>
        self<span style=color:#555>.</span>pos_best_i<span style=color:#555>=</span>[]          <span style=color:#09f;font-style:italic># best position individual</span>
        self<span style=color:#555>.</span>err_best_i<span style=color:#555>=-</span><span style=color:#f60>1</span>          <span style=color:#09f;font-style:italic># best error individual</span>
        self<span style=color:#555>.</span>err_i<span style=color:#555>=-</span><span style=color:#f60>1</span>               <span style=color:#09f;font-style:italic># error individual</span>

        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_dimensions):
            self<span style=color:#555>.</span>velocity_i<span style=color:#555>.</span>append(random<span style=color:#555>.</span>uniform(<span style=color:#555>-</span><span style=color:#f60>1</span>,<span style=color:#f60>1</span>))
            self<span style=color:#555>.</span>position_i<span style=color:#555>.</span>append(x0[i])

    <span style=color:#09f;font-style:italic># evaluate current fitness</span>
    <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>evaluate</span>(self,costFunc):
        self<span style=color:#555>.</span>err_i<span style=color:#555>=</span>costFunc(self<span style=color:#555>.</span>position_i)

        <span style=color:#09f;font-style:italic># check to see if the current position is an individual best</span>
        <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>err_i <span style=color:#555>&lt;</span> self<span style=color:#555>.</span>err_best_i <span style=color:#000;font-weight:700>or</span> self<span style=color:#555>.</span>err_best_i<span style=color:#555>==-</span><span style=color:#f60>1</span>:
            self<span style=color:#555>.</span>pos_best_i<span style=color:#555>=</span>self<span style=color:#555>.</span>position_i
            self<span style=color:#555>.</span>err_best_i<span style=color:#555>=</span>self<span style=color:#555>.</span>err_i

    <span style=color:#09f;font-style:italic># update new particle velocity</span>
    <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>update_velocity</span>(self,pos_best_g):
        w<span style=color:#555>=</span><span style=color:#f60>0.5</span>       <span style=color:#09f;font-style:italic># constant inertia weight (how much to weigh the previous velocity)</span>
        c1<span style=color:#555>=</span><span style=color:#f60>1</span>        <span style=color:#09f;font-style:italic># cognative constant</span>
        c2<span style=color:#555>=</span><span style=color:#f60>2</span>        <span style=color:#09f;font-style:italic># social constant</span>

        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_dimensions):
            r1<span style=color:#555>=</span>random<span style=color:#555>.</span>random()
            r2<span style=color:#555>=</span>random<span style=color:#555>.</span>random()

            vel_cognitive<span style=color:#555>=</span>c1<span style=color:#555>*</span>r1<span style=color:#555>*</span>(self<span style=color:#555>.</span>pos_best_i[i]<span style=color:#555>-</span>self<span style=color:#555>.</span>position_i[i])
            vel_social<span style=color:#555>=</span>c2<span style=color:#555>*</span>r2<span style=color:#555>*</span>(pos_best_g[i]<span style=color:#555>-</span>self<span style=color:#555>.</span>position_i[i])
            self<span style=color:#555>.</span>velocity_i[i]<span style=color:#555>=</span>w<span style=color:#555>*</span>self<span style=color:#555>.</span>velocity_i[i]<span style=color:#555>+</span>vel_cognitive<span style=color:#555>+</span>vel_social

    <span style=color:#09f;font-style:italic># update the particle position based off new velocity updates</span>
    <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>update_position</span>(self,bounds):
        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_dimensions):
            self<span style=color:#555>.</span>position_i[i]<span style=color:#555>=</span>self<span style=color:#555>.</span>position_i[i]<span style=color:#555>+</span>self<span style=color:#555>.</span>velocity_i[i]

            <span style=color:#09f;font-style:italic># adjust maximum position if necessary</span>
            <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>position_i[i]<span style=color:#555>&gt;</span>bounds[i][<span style=color:#f60>1</span>]:
                self<span style=color:#555>.</span>position_i[i]<span style=color:#555>=</span>bounds[i][<span style=color:#f60>1</span>]

            <span style=color:#09f;font-style:italic># adjust minimum position if neseccary</span>
            <span style=color:#069;font-weight:700>if</span> self<span style=color:#555>.</span>position_i[i] <span style=color:#555>&lt;</span> bounds[i][<span style=color:#f60>0</span>]:
                self<span style=color:#555>.</span>position_i[i]<span style=color:#555>=</span>bounds[i][<span style=color:#f60>0</span>]
                
<span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>PSO</span>():
    <span style=color:#069;font-weight:700>def</span> __init__(self,costFunc,x0,bounds,num_particles,maxiter):
        <span style=color:#069;font-weight:700>global</span> num_dimensions

        num_dimensions<span style=color:#555>=</span><span style=color:#366>len</span>(x0)
        err_best_g<span style=color:#555>=-</span><span style=color:#f60>1</span>                   <span style=color:#09f;font-style:italic># best error for group</span>
        pos_best_g<span style=color:#555>=</span>[]                   <span style=color:#09f;font-style:italic># best position for group</span>

        <span style=color:#09f;font-style:italic># establish the swarm</span>
        swarm<span style=color:#555>=</span>[]
        <span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_particles):
            swarm<span style=color:#555>.</span>append(Particle(x0))

        <span style=color:#09f;font-style:italic># begin optimization loop</span>
        i<span style=color:#555>=</span><span style=color:#f60>0</span>
        <span style=color:#069;font-weight:700>while</span> i <span style=color:#555>&lt;</span> maxiter:
            <span style=color:#09f;font-style:italic>#print i,err_best_g</span>
            <span style=color:#09f;font-style:italic># cycle through particles in swarm and evaluate fitness</span>
            <span style=color:#069;font-weight:700>for</span> j <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_particles):
                swarm[j]<span style=color:#555>.</span>evaluate(costFunc)

                <span style=color:#09f;font-style:italic># determine if current particle is the best (globally)</span>
                <span style=color:#069;font-weight:700>if</span> swarm[j]<span style=color:#555>.</span>err_i <span style=color:#555>&lt;</span> err_best_g <span style=color:#000;font-weight:700>or</span> err_best_g <span style=color:#555>==</span> <span style=color:#555>-</span><span style=color:#f60>1</span>:
                    pos_best_g<span style=color:#555>=</span><span style=color:#366>list</span>(swarm[j]<span style=color:#555>.</span>position_i)
                    err_best_g<span style=color:#555>=</span><span style=color:#366>float</span>(swarm[j]<span style=color:#555>.</span>err_i)

            <span style=color:#09f;font-style:italic># cycle through swarm and update velocities and position</span>
            <span style=color:#069;font-weight:700>for</span> j <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>0</span>,num_particles):
                swarm[j]<span style=color:#555>.</span>update_velocity(pos_best_g)
                swarm[j]<span style=color:#555>.</span>update_position(bounds)
            i<span style=color:#555>+=</span><span style=color:#f60>1</span>

        <span style=color:#09f;font-style:italic># print final results</span>
        <span style=color:#069;font-weight:700>print</span> <span style=color:#c30>&#39;FINAL:&#39;</span>
        <span style=color:#069;font-weight:700>print</span> pos_best_g
        <span style=color:#069;font-weight:700>print</span> err_best_g

<span style=color:#069;font-weight:700>if</span> __name__ <span style=color:#555>==</span> <span style=color:#c30>&#34;__PSO__&#34;</span>:
    main()

<span style=color:#09f;font-style:italic>#--- RUN ----------------------------------------------------------------------+</span>

initial<span style=color:#555>=</span>[<span style=color:#f60>5</span>,<span style=color:#f60>5</span>]               <span style=color:#09f;font-style:italic># initial starting location [x1,x2...]</span>
bounds<span style=color:#555>=</span>[(<span style=color:#555>-</span><span style=color:#f60>10</span>,<span style=color:#f60>10</span>),(<span style=color:#555>-</span><span style=color:#f60>10</span>,<span style=color:#f60>10</span>)]  <span style=color:#09f;font-style:italic># input bounds [(x1_min,x1_max),(x2_min,x2_max)...]</span>
PSO(func1,initial,bounds,num_particles<span style=color:#555>=</span><span style=color:#f60>15</span>,maxiter<span style=color:#555>=</span><span style=color:#f60>30</span>)

<span style=color:#09f;font-style:italic>#--- END ----------------------------------------------------------------------+</span></code></pre></div><p>I hope this was helpful! If you want, you can download the entire code from my GitHub (<a target=_blank href=https://github.com/nathanrooy/Particle-Swarm-Optimization-with-Python/blob/master/simple-particle-swarm-optimization.py>here</a>). Check back later for my post on a more advanced particle swarm optimization routine.</p></div><hr></div><div class=footer><center>&copy; <a href=/about>Nathan A. Rooy</a>.<br>Built with <a target=_blank href=https://gohugo.io/ rel=nofollow>Hugo</a>.
Powered by <a target=_blank href=http://www.github.com>GitHub</a></center></div></body></html>